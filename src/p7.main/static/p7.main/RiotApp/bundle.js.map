{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap d95d52134290c7e4b5a6","webpack:///./~/riot/riot.js","webpack:///./src/components/header.tag","webpack:///./src/components/itemlist.tag","webpack:///./src/pages/home.tag","webpack:///./src/pages/projects.tag","webpack:///./src/event-helper.js","webpack:///./src/index.js","webpack:///./src/router.js","webpack:///./src/stores/itemstore.js","webpack:///./src/css/index.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/riot-observable/dist/observable.js","webpack:///./~/riot-route/index.js","webpack:///./~/riotcontrol/riotcontrol.js","webpack:///./~/style-loader/addStyles.js","webpack:///./src/css/index.css?851f"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","riot","global","factory","this","isBoolAttr","value","RE_BOOL_ATTRS","test","isFunction","T_FUNCTION","isObject","T_OBJECT","isUndefined","T_UNDEF","isString","T_STRING","isBlank","isArray","Array","isWritable","obj","key","descriptor","Object","getOwnPropertyDescriptor","writable","isReservedName","RE_RESERVED_NAMES","$$","selector","ctx","document","querySelectorAll","$","querySelector","createFrag","createDocumentFragment","createDOMPlaceholder","createTextNode","mkEl","name","createElement","setInnerHTML","container","html","innerHTML","doc","DOMParser","parseFromString","node","ownerDocument","importNode","documentElement","appendChild","toggleVisibility","dom","show","style","display","remAttr","removeAttribute","styleObjectToString","keys","reduce","acc","prop","getAttr","getAttribute","setAttr","val","xlink","XLINK_REGEX","exec","setAttributeNS","XLINK_NS","setAttribute","safeInsert","root","curr","next","insertBefore","parentNode","walkAttrs","fn","RE_HTML_ATTRS","toLowerCase","walkNodes","context","res","firstChild","nextSibling","each","list","len","length","i","contains","array","item","indexOf","toCamel","str","replace","_","toUpperCase","startsWith","slice","defineProperty","el","options","extend","enumerable","configurable","src","args","arguments","handleEvent","handler","e","ptag","__","parent","currentTarget","target","srcElement","which","charCode","keyCode","preventUpdate","getImmediateCustomParentTag","isMounted","update","setEventHandler","tag","eventName","cb","bind","RE_EVENTS_PREFIX","listeners","push","RIOT_EVENTS_KEY","removeEventListener","addEventListener","updateDataIs","expr","tagName","conf","isVirtual","head","ref","unmount","impl","__TAG_IMPL","hasImpl","initChildTag","attrs","a","mount","makeReplaceVirtual","onUnmount","delName","opts","dataIs","tags","_tags","arrayishRemove","normalizeAttrName","attrName","ATTRS_PREFIX","CASE_SENSITIVE_ATTRIBUTES","updateExpression","isObj","attr","isToggle","SHOW_DIRECTIVE","HIDE_DIRECTIVE","isStyleAttr","isClassAttr","_riot_id","tmpl","create","JSON","stringify","isAttrRemoved","bool","isRtag","wasParsedOnce","hidden","IE_VERSION","nodeValue","updateAllExpressions","expressions","mkitem","base","pos","unmountRedundant","items","j","remove","apply","splice","moveNestedTags","this$1","moveChildTag","move","nextTag","moveVirtual","insert","makeVirtual","append","_each","LOOP_DIRECTIVE","hasKeys","mustReorder","LOOP_NO_REORDER_DIRECTIVE","getTagName","placeholder","child","getTag","ifExpr","CONDITIONAL_DIRECTIVE","oldItems","isLoop","isAnonymous","loopKeys","removeChild","frag","isObject$$1","map","filter","doReorder","oldPos","isNew","mustAppend","mustCreate","Tag$1","cloneNode","index","arrayishAdd","t","parseExpressions","mustIncludeRoot","tree","children","tagImpl","type","nodeType","hasExpr","IfExpr","init","IS_DIRECTIVE","attributes","parentElement","outerHTML","parseAttributes","REF_DIRECTIVES","RefExpr","specialTags","select","trim","selectedIndex","tname","rootEls","childElementCount","replaceYield","reHasYield","reYieldSrc","text","reYieldDest","def","reYieldAll","mkdom","match","GENERIC","tblTags","Tag$2","css","onCreate","tag$1","class","constructor","mountTo","styleManager","inject","add","tag2$1","mount$1","pushTagsTo","riotTag","elem","allTags","selectTags","split","nodeList","_el","mixin$1","mix","g","mixins_id","store","globals","mixins","Error","prototype","update$1","__TAGS_CACHE","unregister$1","updateOpts","instAttrs","skipAnonymous","settings$1","skipAnonymousTags","cleanUpData","implAttrs","propsInSyncWithParent","observable$1","_tag","virts","tail","__uid","data","nextOpts","canTrigger","shouldUpdate","inheritFrom","trigger","instance","props","propsBlacklist","proto","getPrototypeOf","concat","getOwnPropertyNames","hasGetterSetter","get","set","hasOwnProperty","isPrototypeOf","k","v","globalMixin","GLOBAL_MIXIN","mixin","one","mustKeepRoot","tagIndex","forEach","unmountAll","off","mustSync","newPos","skipDataIs","namedTag","o","ensureArray","dest","isArr","hasIndex","oldIndex","implClass","_innerHTML","replaceChild","sib","styleNode","cssTextProp","WIN","window","undefined","RE_SPECIAL_TAGS","RE_SPECIAL_TAGS_NO_OPTION","viewbox","documentMode","check","freeze","byName","remainder","needsInject","newNode","userNode","getElementsByTagName","styleSheet","join","cssText","brackets","UNDEF","_loopback","re","_rewrite","bp","_cache","RegExp","source","REGLOB","_create","pair","DEFAULT","_pairs","arr","UNSUPPORTED","NEED_ESCAPE","S_QBLOCKS","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","b","_settings","R_MLCOMMS","R_STRINGS","FINDBRACES","(","[","{","_bp","unescapeStr","s","isexpr","parts","skipBraces","ch","ix","recch","lastIndex","start","settings","_tmpl","_logErr","err","riotData","errorHandler","console","error","_getTmpl","Function","qstr","RE_DQUOTE","_parseExpr","RE_QBMARK","asText","mm","lv","ir","RE_BREND","RE_QBLOCK","div","CH_IDEXPR","cnt","RE_CSNAME","jsb","rightContext","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","clearCache","String","fromCharCode","version","callbacks","defineProperties","on","event","fns","arguments$1","arglen","misc","stub","pristine","current","attrValue","rawValue","hasExp","old","customParent","tagOrDom","refs","tr","th","td","col","version$1","core","Tag","tag2","unregister","util","vdom","Tag$$1","tag$$1","tag2$$1","mount$$1","mixin$$1","update$$1","unregister$$1","version$$1","observable","riot$1","currentView","routeState","view","navItems","title","route","evt","_this","control","EVT","loadItems","loadItemsSuccess","_interopRequireDefault","__esModule","default","_riotcontrol","_riotcontrol2","_classCallCheck","Constructor","TypeError","_createClass","protoProps","staticProps","_riotRoute","_riotRoute2","Router","_currentView","_views","_defaultView","_handleRoute","_loadView","ItemStore","bindEvents","setTimeout","itemStore","addStore","toString","result","mediaQuery","alreadyImportedModules","_interopDefault","ex","DEFAULT_PARSER","path","DEFAULT_SECOND_PARSER","f","debounce","delay","clearTimeout","autoExec","debouncedEmit","emit","win","ADD_EVENT_LISTENER","POPSTATE","HASHCHANGE","clickEvent","click","central","normalize","getPathFromRoot","href","loc","RE_ORIGIN","getPathFromBase","force","isRoot","emitStackLevel","MAX_EMIT_STACK_LEVEL","emitStack","TRIGGER","first","shift","metaKey","ctrlKey","shiftKey","defaultPrevented","nodeName","HAS_ATTRIBUTE","go","preventDefault","shouldReplace","hist","replaceState","pushState","routeFound","parser","secondParser","EVENT_LISTENER","REMOVE_EVENT_LISTENER","history","location","prot","ontouchstart","started","second","third","r","some","action","mainRouter","newSubRouter","router","stop","arg","fn2","query","q","readyState","onreadystatechange","RiotControl","_stores","reset","api","addStylesToDom","styles","domStyle","stylesInDom","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","idx","createStyleElement","createLinkElement","linkElement","rel","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","applyToTag","newObj","replaceText","cssNode","childNodes","unescape","encodeURIComponent","blob","oldSrc","memoize","memo","isOldIE","self","navigator","userAgent","newList","mayRemove","textStore","replacement","Boolean","content","locals"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!*****************!*\\\n  !*** multi app ***!\n  \\*****************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(/*! ./src/index.js */7);\n\n\n/***/ }),\n/* 1 */\n/*!************************!*\\\n  !*** ./~/riot/riot.js ***!\n  \\************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {/* Riot v3.4.3, @license MIT */\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.riot = global.riot || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\tvar __TAGS_CACHE = [];\n\tvar __TAG_IMPL = {};\n\tvar GLOBAL_MIXIN = '__global_mixin';\n\tvar ATTRS_PREFIX = 'riot-';\n\tvar REF_DIRECTIVES = ['ref', 'data-ref'];\n\tvar IS_DIRECTIVE = 'data-is';\n\tvar CONDITIONAL_DIRECTIVE = 'if';\n\tvar LOOP_DIRECTIVE = 'each';\n\tvar LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';\n\tvar SHOW_DIRECTIVE = 'show';\n\tvar HIDE_DIRECTIVE = 'hide';\n\tvar RIOT_EVENTS_KEY = '__riot-events__';\n\tvar T_STRING = 'string';\n\tvar T_OBJECT = 'object';\n\tvar T_UNDEF  = 'undefined';\n\tvar T_FUNCTION = 'function';\n\tvar XLINK_NS = 'http://www.w3.org/1999/xlink';\n\tvar XLINK_REGEX = /^xlink:(\\w+)/;\n\tvar WIN = typeof window === T_UNDEF ? undefined : window;\n\tvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\n\tvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\n\tvar RE_EVENTS_PREFIX = /^on/;\n\tvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\n\tvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\n\tvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\n\tvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\n\tvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\t\n\t/**\n\t * Check Check if the passed argument is undefined\n\t * @param   { String } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isBoolAttr(value) {\n\t  return RE_BOOL_ATTRS.test(value)\n\t}\n\t\n\t/**\n\t * Check if passed argument is a function\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isFunction(value) {\n\t  return typeof value === T_FUNCTION\n\t}\n\t\n\t/**\n\t * Check if passed argument is an object, exclude null\n\t * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isObject(value) {\n\t  return value && typeof value === T_OBJECT // typeof null is 'object'\n\t}\n\t\n\t/**\n\t * Check if passed argument is undefined\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isUndefined(value) {\n\t  return typeof value === T_UNDEF\n\t}\n\t\n\t/**\n\t * Check if passed argument is a string\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isString(value) {\n\t  return typeof value === T_STRING\n\t}\n\t\n\t/**\n\t * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n\t * @param { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isBlank(value) {\n\t  return isUndefined(value) || value === null || value === ''\n\t}\n\t\n\t/**\n\t * Check if passed argument is a kind of array\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isArray(value) {\n\t  return Array.isArray(value) || value instanceof Array\n\t}\n\t\n\t/**\n\t * Check whether object's property could be overridden\n\t * @param   { Object }  obj - source object\n\t * @param   { String }  key - object property\n\t * @returns { Boolean } -\n\t */\n\tfunction isWritable(obj, key) {\n\t  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\t  return isUndefined(obj[key]) || descriptor && descriptor.writable\n\t}\n\t\n\t/**\n\t * Check if passed argument is a reserved name\n\t * @param   { String } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isReservedName(value) {\n\t  return RE_RESERVED_NAMES.test(value)\n\t}\n\t\n\tvar check = Object.freeze({\n\t\tisBoolAttr: isBoolAttr,\n\t\tisFunction: isFunction,\n\t\tisObject: isObject,\n\t\tisUndefined: isUndefined,\n\t\tisString: isString,\n\t\tisBlank: isBlank,\n\t\tisArray: isArray,\n\t\tisWritable: isWritable,\n\t\tisReservedName: isReservedName\n\t});\n\t\n\t/**\n\t * Shorter and fast way to select multiple nodes in the DOM\n\t * @param   { String } selector - DOM selector\n\t * @param   { Object } ctx - DOM node where the targets of our search will is located\n\t * @returns { Object } dom nodes found\n\t */\n\tfunction $$(selector, ctx) {\n\t  return (ctx || document).querySelectorAll(selector)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select a single node in the DOM\n\t * @param   { String } selector - unique dom selector\n\t * @param   { Object } ctx - DOM node where the target of our search will is located\n\t * @returns { Object } dom node found\n\t */\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\t/**\n\t * Create a document fragment\n\t * @returns { Object } document fragment\n\t */\n\tfunction createFrag() {\n\t  return document.createDocumentFragment()\n\t}\n\t\n\t/**\n\t * Create a document text node\n\t * @returns { Object } create a text node to use as placeholder\n\t */\n\tfunction createDOMPlaceholder() {\n\t  return document.createTextNode('')\n\t}\n\t\n\t/**\n\t * Create a generic DOM node\n\t * @param   { String } name - name of the DOM node we want to create\n\t * @returns { Object } DOM node just created\n\t */\n\tfunction mkEl(name) {\n\t  return document.createElement(name)\n\t}\n\t\n\t/**\n\t * Set the inner html of any DOM node SVGs included\n\t * @param { Object } container - DOM node where we'll inject new html\n\t * @param { String } html - html to inject\n\t */\n\t/* istanbul ignore next */\n\tfunction setInnerHTML(container, html) {\n\t  if (!isUndefined(container.innerHTML))\n\t    { container.innerHTML = html; }\n\t    // some browsers do not support innerHTML on the SVGs tags\n\t  else {\n\t    var doc = new DOMParser().parseFromString(html, 'application/xml');\n\t    var node = container.ownerDocument.importNode(doc.documentElement, true);\n\t    container.appendChild(node);\n\t  }\n\t}\n\t\n\t/**\n\t * Toggle the visibility of any DOM node\n\t * @param   { Object }  dom - DOM node we want to hide\n\t * @param   { Boolean } show - do we want to show it?\n\t */\n\t\n\tfunction toggleVisibility(dom, show) {\n\t  dom.style.display = show ? '' : 'none';\n\t  dom['hidden'] = show ? false : true;\n\t}\n\t\n\t/**\n\t * Remove any DOM attribute from a node\n\t * @param   { Object } dom - DOM node we want to update\n\t * @param   { String } name - name of the property we want to remove\n\t */\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name);\n\t}\n\t\n\t/**\n\t * Convert a style object to a string\n\t * @param   { Object } style - style object we need to parse\n\t * @returns { String } resulting css string\n\t * @example\n\t * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n\t */\n\tfunction styleObjectToString(style) {\n\t  return Object.keys(style).reduce(function (acc, prop) {\n\t    return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n\t  }, '')\n\t}\n\t\n\t/**\n\t * Get the value of any DOM attribute on a node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { String } name - name of the attribute we want to get\n\t * @returns { String | undefined } name of the node attribute whether it exists\n\t */\n\tfunction getAttr(dom, name) {\n\t  return dom.getAttribute(name)\n\t}\n\t\n\t/**\n\t * Set any DOM attribute\n\t * @param { Object } dom - DOM node we want to update\n\t * @param { String } name - name of the property we want to set\n\t * @param { String } val - value of the property we want to set\n\t */\n\tfunction setAttr(dom, name, val) {\n\t  var xlink = XLINK_REGEX.exec(name);\n\t  if (xlink && xlink[1])\n\t    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n\t  else\n\t    { dom.setAttribute(name, val); }\n\t}\n\t\n\t/**\n\t * Insert safely a tag to fix #1962 #1649\n\t * @param   { HTMLElement } root - children container\n\t * @param   { HTMLElement } curr - node to insert\n\t * @param   { HTMLElement } next - node that should preceed the current node inserted\n\t */\n\tfunction safeInsert(root, curr, next) {\n\t  root.insertBefore(curr, next.parentNode && next);\n\t}\n\t\n\t/**\n\t * Minimize risk: only zero or one _space_ between attr & value\n\t * @param   { String }   html - html string we want to parse\n\t * @param   { Function } fn - callback function to apply on any attribute found\n\t */\n\tfunction walkAttrs(html, fn) {\n\t  if (!html)\n\t    { return }\n\t  var m;\n\t  while (m = RE_HTML_ATTRS.exec(html))\n\t    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n\t}\n\t\n\t/**\n\t * Walk down recursively all the children tags starting dom node\n\t * @param   { Object }   dom - starting node where we will start the recursion\n\t * @param   { Function } fn - callback to transform the child node just found\n\t * @param   { Object }   context - fn can optionally return an object, which is passed to children\n\t */\n\tfunction walkNodes(dom, fn, context) {\n\t  if (dom) {\n\t    var res = fn(dom, context);\n\t    var next;\n\t    // stop the recursion\n\t    if (res === false) { return }\n\t\n\t    dom = dom.firstChild;\n\t\n\t    while (dom) {\n\t      next = dom.nextSibling;\n\t      walkNodes(dom, fn, res);\n\t      dom = next;\n\t    }\n\t  }\n\t}\n\t\n\tvar dom = Object.freeze({\n\t\t$$: $$,\n\t\t$: $,\n\t\tcreateFrag: createFrag,\n\t\tcreateDOMPlaceholder: createDOMPlaceholder,\n\t\tmkEl: mkEl,\n\t\tsetInnerHTML: setInnerHTML,\n\t\ttoggleVisibility: toggleVisibility,\n\t\tremAttr: remAttr,\n\t\tstyleObjectToString: styleObjectToString,\n\t\tgetAttr: getAttr,\n\t\tsetAttr: setAttr,\n\t\tsafeInsert: safeInsert,\n\t\twalkAttrs: walkAttrs,\n\t\twalkNodes: walkNodes\n\t});\n\t\n\tvar styleNode;\n\tvar cssTextProp;\n\tvar byName = {};\n\tvar remainder = [];\n\tvar needsInject = false;\n\t\n\t// skip the following code on the server\n\tif (WIN) {\n\t  styleNode = (function () {\n\t    // create a new style element with the correct type\n\t    var newNode = mkEl('style');\n\t    setAttr(newNode, 'type', 'text/css');\n\t\n\t    // replace any user node or insert the new one into the head\n\t    var userNode = $('style[type=riot]');\n\t    /* istanbul ignore next */\n\t    if (userNode) {\n\t      if (userNode.id) { newNode.id = userNode.id; }\n\t      userNode.parentNode.replaceChild(newNode, userNode);\n\t    }\n\t    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\t\n\t    return newNode\n\t  })();\n\t  cssTextProp = styleNode.styleSheet;\n\t}\n\t\n\t/**\n\t * Object that will be used to inject and manage the css of every tag instance\n\t */\n\tvar styleManager = {\n\t  styleNode: styleNode,\n\t  /**\n\t   * Save a tag style to be later injected into DOM\n\t   * @param { String } css - css string\n\t   * @param { String } name - if it's passed we will map the css to a tagname\n\t   */\n\t  add: function add(css, name) {\n\t    if (name) { byName[name] = css; }\n\t    else { remainder.push(css); }\n\t    needsInject = true;\n\t  },\n\t  /**\n\t   * Inject all previously saved tag styles into DOM\n\t   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n\t   */\n\t  inject: function inject() {\n\t    if (!WIN || !needsInject) { return }\n\t    needsInject = false;\n\t    var style = Object.keys(byName)\n\t      .map(function(k) { return byName[k] })\n\t      .concat(remainder).join('\\n');\n\t    /* istanbul ignore next */\n\t    if (cssTextProp) { cssTextProp.cssText = style; }\n\t    else { styleNode.innerHTML = style; }\n\t  }\n\t};\n\t\n\t/**\n\t * The riot template engine\n\t * @version v3.0.3\n\t */\n\t/**\n\t * riot.util.brackets\n\t *\n\t * - `brackets    ` - Returns a string or regex based on its parameter\n\t * - `brackets.set` - Change the current riot brackets\n\t *\n\t * @module\n\t */\n\t\n\t/* global riot */\n\t\n\t/* istanbul ignore next */\n\tvar brackets = (function (UNDEF) {\n\t\n\t  var\n\t    REGLOB = 'g',\n\t\n\t    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\t\n\t    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\t\n\t    S_QBLOCKS = R_STRINGS.source + '|' +\n\t      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n\t      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\t\n\t    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\t\n\t    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\t\n\t    FINDBRACES = {\n\t      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n\t      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n\t      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n\t    },\n\t\n\t    DEFAULT = '{ }';\n\t\n\t  var _pairs = [\n\t    '{', '}',\n\t    '{', '}',\n\t    /{[^}]*}/,\n\t    /\\\\([{}])/g,\n\t    /\\\\({)|{/g,\n\t    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n\t    DEFAULT,\n\t    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n\t    /(^|[^\\\\]){=[\\S\\s]*?}/\n\t  ];\n\t\n\t  var\n\t    cachedBrackets = UNDEF,\n\t    _regex,\n\t    _cache = [],\n\t    _settings;\n\t\n\t  function _loopback (re) { return re }\n\t\n\t  function _rewrite (re, bp) {\n\t    if (!bp) { bp = _cache; }\n\t    return new RegExp(\n\t      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n\t    )\n\t  }\n\t\n\t  function _create (pair) {\n\t    if (pair === DEFAULT) { return _pairs }\n\t\n\t    var arr = pair.split(' ');\n\t\n\t    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n\t      throw new Error('Unsupported brackets \"' + pair + '\"')\n\t    }\n\t    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\t\n\t    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n\t    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n\t    arr[6] = _rewrite(_pairs[6], arr);\n\t    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);\n\t    arr[8] = pair;\n\t    return arr\n\t  }\n\t\n\t  function _brackets (reOrIdx) {\n\t    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n\t  }\n\t\n\t  _brackets.split = function split (str, tmpl, _bp) {\n\t    // istanbul ignore next: _bp is for the compiler\n\t    if (!_bp) { _bp = _cache; }\n\t\n\t    var\n\t      parts = [],\n\t      match,\n\t      isexpr,\n\t      start,\n\t      pos,\n\t      re = _bp[6];\n\t\n\t    isexpr = start = re.lastIndex = 0;\n\t\n\t    while ((match = re.exec(str))) {\n\t\n\t      pos = match.index;\n\t\n\t      if (isexpr) {\n\t\n\t        if (match[2]) {\n\t          re.lastIndex = skipBraces(str, match[2], re.lastIndex);\n\t          continue\n\t        }\n\t        if (!match[3]) {\n\t          continue\n\t        }\n\t      }\n\t\n\t      if (!match[1]) {\n\t        unescapeStr(str.slice(start, pos));\n\t        start = re.lastIndex;\n\t        re = _bp[6 + (isexpr ^= 1)];\n\t        re.lastIndex = start;\n\t      }\n\t    }\n\t\n\t    if (str && start < str.length) {\n\t      unescapeStr(str.slice(start));\n\t    }\n\t\n\t    return parts\n\t\n\t    function unescapeStr (s) {\n\t      if (tmpl || isexpr) {\n\t        parts.push(s && s.replace(_bp[5], '$1'));\n\t      } else {\n\t        parts.push(s);\n\t      }\n\t    }\n\t\n\t    function skipBraces (s, ch, ix) {\n\t      var\n\t        match,\n\t        recch = FINDBRACES[ch];\n\t\n\t      recch.lastIndex = ix;\n\t      ix = 1;\n\t      while ((match = recch.exec(s))) {\n\t        if (match[1] &&\n\t          !(match[1] === ch ? ++ix : --ix)) { break }\n\t      }\n\t      return ix ? s.length : recch.lastIndex\n\t    }\n\t  };\n\t\n\t  _brackets.hasExpr = function hasExpr (str) {\n\t    return _cache[4].test(str)\n\t  };\n\t\n\t  _brackets.loopKeys = function loopKeys (expr) {\n\t    var m = expr.match(_cache[9]);\n\t\n\t    return m\n\t      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n\t      : { val: expr.trim() }\n\t  };\n\t\n\t  _brackets.array = function array (pair) {\n\t    return pair ? _create(pair) : _cache\n\t  };\n\t\n\t  function _reset (pair) {\n\t    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n\t      _cache = _create(pair);\n\t      _regex = pair === DEFAULT ? _loopback : _rewrite;\n\t      _cache[9] = _regex(_pairs[9]);\n\t    }\n\t    cachedBrackets = pair;\n\t  }\n\t\n\t  function _setSettings (o) {\n\t    var b;\n\t\n\t    o = o || {};\n\t    b = o.brackets;\n\t    Object.defineProperty(o, 'brackets', {\n\t      set: _reset,\n\t      get: function () { return cachedBrackets },\n\t      enumerable: true\n\t    });\n\t    _settings = o;\n\t    _reset(b);\n\t  }\n\t\n\t  Object.defineProperty(_brackets, 'settings', {\n\t    set: _setSettings,\n\t    get: function () { return _settings }\n\t  });\n\t\n\t  /* istanbul ignore next: in the browser riot is always in the scope */\n\t  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n\t  _brackets.set = _reset;\n\t\n\t  _brackets.R_STRINGS = R_STRINGS;\n\t  _brackets.R_MLCOMMS = R_MLCOMMS;\n\t  _brackets.S_QBLOCKS = S_QBLOCKS;\n\t\n\t  return _brackets\n\t\n\t})();\n\t\n\t/**\n\t * @module tmpl\n\t *\n\t * tmpl          - Root function, returns the template value, render with data\n\t * tmpl.hasExpr  - Test the existence of a expression inside a string\n\t * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n\t */\n\t\n\t/* istanbul ignore next */\n\tvar tmpl = (function () {\n\t\n\t  var _cache = {};\n\t\n\t  function _tmpl (str, data) {\n\t    if (!str) { return str }\n\t\n\t    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n\t  }\n\t\n\t  _tmpl.hasExpr = brackets.hasExpr;\n\t\n\t  _tmpl.loopKeys = brackets.loopKeys;\n\t\n\t  // istanbul ignore next\n\t  _tmpl.clearCache = function () { _cache = {}; };\n\t\n\t  _tmpl.errorHandler = null;\n\t\n\t  function _logErr (err, ctx) {\n\t\n\t    err.riotData = {\n\t      tagName: ctx && ctx.__ && ctx.__.tagName,\n\t      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n\t    };\n\t\n\t    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n\t    else if (\n\t      typeof console !== 'undefined' &&\n\t      typeof console.error === 'function'\n\t    ) {\n\t      if (err.riotData.tagName) {\n\t        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName);\n\t      }\n\t      console.error(err);\n\t    }\n\t  }\n\t\n\t  function _create (str) {\n\t    var expr = _getTmpl(str);\n\t\n\t    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\t\n\t    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n\t  }\n\t\n\t  var\n\t    CH_IDEXPR = String.fromCharCode(0x2057),\n\t    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n\t    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n\t    RE_DQUOTE = /\\u2057/g,\n\t    RE_QBMARK = /\\u2057(\\d+)~/g;\n\t\n\t  function _getTmpl (str) {\n\t    var\n\t      qstr = [],\n\t      expr,\n\t      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\t\n\t    if (parts.length > 2 || parts[0]) {\n\t      var i, j, list = [];\n\t\n\t      for (i = j = 0; i < parts.length; ++i) {\n\t\n\t        expr = parts[i];\n\t\n\t        if (expr && (expr = i & 1\n\t\n\t            ? _parseExpr(expr, 1, qstr)\n\t\n\t            : '\"' + expr\n\t                .replace(/\\\\/g, '\\\\\\\\')\n\t                .replace(/\\r\\n?|\\n/g, '\\\\n')\n\t                .replace(/\"/g, '\\\\\"') +\n\t              '\"'\n\t\n\t          )) { list[j++] = expr; }\n\t\n\t      }\n\t\n\t      expr = j < 2 ? list[0]\n\t           : '[' + list.join(',') + '].join(\"\")';\n\t\n\t    } else {\n\t\n\t      expr = _parseExpr(parts[1], 0, qstr);\n\t    }\n\t\n\t    if (qstr[0]) {\n\t      expr = expr.replace(RE_QBMARK, function (_, pos) {\n\t        return qstr[pos]\n\t          .replace(/\\r/g, '\\\\r')\n\t          .replace(/\\n/g, '\\\\n')\n\t      });\n\t    }\n\t    return expr\n\t  }\n\t\n\t  var\n\t    RE_BREND = {\n\t      '(': /[()]/g,\n\t      '[': /[[\\]]/g,\n\t      '{': /[{}]/g\n\t    };\n\t\n\t  function _parseExpr (expr, asText, qstr) {\n\t\n\t    expr = expr\n\t          .replace(RE_QBLOCK, function (s, div) {\n\t            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n\t          })\n\t          .replace(/\\s+/g, ' ').trim()\n\t          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\t\n\t    if (expr) {\n\t      var\n\t        list = [],\n\t        cnt = 0,\n\t        match;\n\t\n\t      while (expr &&\n\t            (match = expr.match(RE_CSNAME)) &&\n\t            !match.index\n\t        ) {\n\t        var\n\t          key,\n\t          jsb,\n\t          re = /,|([[{(])|$/g;\n\t\n\t        expr = RegExp.rightContext;\n\t        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\t\n\t        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\t\n\t        jsb  = expr.slice(0, match.index);\n\t        expr = RegExp.rightContext;\n\t\n\t        list[cnt++] = _wrapExpr(jsb, 1, key);\n\t      }\n\t\n\t      expr = !cnt ? _wrapExpr(expr, asText)\n\t           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n\t    }\n\t    return expr\n\t\n\t    function skipBraces (ch, re) {\n\t      var\n\t        mm,\n\t        lv = 1,\n\t        ir = RE_BREND[ch];\n\t\n\t      ir.lastIndex = re.lastIndex;\n\t      while (mm = ir.exec(expr)) {\n\t        if (mm[0] === ch) { ++lv; }\n\t        else if (!--lv) { break }\n\t      }\n\t      re.lastIndex = lv ? expr.length : ir.lastIndex;\n\t    }\n\t  }\n\t\n\t  // istanbul ignore next: not both\n\t  var // eslint-disable-next-line max-len\n\t    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n\t    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n\t    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\t\n\t  function _wrapExpr (expr, asText, key) {\n\t    var tb;\n\t\n\t    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n\t      if (mvar) {\n\t        pos = tb ? 0 : pos + match.length;\n\t\n\t        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n\t          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n\t          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n\t        } else if (pos) {\n\t          tb = !JS_NOPROPS.test(s.slice(pos));\n\t        }\n\t      }\n\t      return match\n\t    });\n\t\n\t    if (tb) {\n\t      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n\t    }\n\t\n\t    if (key) {\n\t\n\t      expr = (tb\n\t          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n\t        ) + '?\"' + key + '\":\"\"';\n\t\n\t    } else if (asText) {\n\t\n\t      expr = 'function(v){' + (tb\n\t          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n\t        ) + ';return v||v===0?v:\"\"}.call(this)';\n\t    }\n\t\n\t    return expr\n\t  }\n\t\n\t  _tmpl.version = brackets.version = 'v3.0.3';\n\t\n\t  return _tmpl\n\t\n\t})();\n\t\n\t/* istanbul ignore next */\n\tvar observable$1 = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {};\n\t\n\t  /**\n\t   * Private variables\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice;\n\t\n\t  /**\n\t   * Public Api\n\t   */\n\t\n\t  // extend the el object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given `event` ands\n\t     * execute the `callback` each time an event is triggered.\n\t     * @param  { String } event - event id\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(event, fn) {\n\t        if (typeof fn == 'function')\n\t          { (callbacks[event] = callbacks[event] || []).push(fn); }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given `event` listeners\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(event, fn) {\n\t        if (event == '*' && !fn) { callbacks = {}; }\n\t        else {\n\t          if (fn) {\n\t            var arr = callbacks[event];\n\t            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t              if (cb == fn) { arr.splice(i--, 1); }\n\t            }\n\t          } else { delete callbacks[event]; }\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given `event` and\n\t     * execute the `callback` at most once\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(event, fn) {\n\t        function on() {\n\t          el.off(event, on);\n\t          fn.apply(el, arguments);\n\t        }\n\t        return el.on(event, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to\n\t     * the given `event`\n\t     * @param   { String } event - event id\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(event) {\n\t        var arguments$1 = arguments;\n\t\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns,\n\t          fn,\n\t          i;\n\t\n\t        for (i = 0; i < arglen; i++) {\n\t          args[i] = arguments$1[i + 1]; // skip first argument\n\t        }\n\t\n\t        fns = slice.call(callbacks[event] || [], 0);\n\t\n\t        for (i = 0; fn = fns[i]; ++i) {\n\t          fn.apply(el, args);\n\t        }\n\t\n\t        if (callbacks['*'] && event != '*')\n\t          { el.trigger.apply(el, ['*', event].concat(args)); }\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  });\n\t\n\t  return el\n\t\n\t};\n\t\n\t/**\n\t * Specialized function for looping an array-like collection with `each={}`\n\t * @param   { Array } list - collection of items\n\t * @param   {Function} fn - callback function\n\t * @returns { Array } the array looped\n\t */\n\tfunction each(list, fn) {\n\t  var len = list ? list.length : 0;\n\t  var i = 0;\n\t  for (; i < len; ++i) {\n\t    fn(list[i], i);\n\t  }\n\t  return list\n\t}\n\t\n\t/**\n\t * Check whether an array contains an item\n\t * @param   { Array } array - target array\n\t * @param   { * } item - item to test\n\t * @returns { Boolean } -\n\t */\n\tfunction contains(array, item) {\n\t  return array.indexOf(item) !== -1\n\t}\n\t\n\t/**\n\t * Convert a string containing dashes to camel case\n\t * @param   { String } str - input string\n\t * @returns { String } my-string -> myString\n\t */\n\tfunction toCamel(str) {\n\t  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n\t}\n\t\n\t/**\n\t * Faster String startsWith alternative\n\t * @param   { String } str - source string\n\t * @param   { String } value - test string\n\t * @returns { Boolean } -\n\t */\n\tfunction startsWith(str, value) {\n\t  return str.slice(0, value.length) === value\n\t}\n\t\n\t/**\n\t * Helper function to set an immutable property\n\t * @param   { Object } el - object where the new property will be set\n\t * @param   { String } key - object key where the new property will be stored\n\t * @param   { * } value - value of the new property\n\t * @param   { Object } options - set the propery overriding the default options\n\t * @returns { Object } - the initial object\n\t */\n\tfunction defineProperty(el, key, value, options) {\n\t  Object.defineProperty(el, key, extend({\n\t    value: value,\n\t    enumerable: false,\n\t    writable: false,\n\t    configurable: true\n\t  }, options));\n\t  return el\n\t}\n\t\n\t/**\n\t * Extend any object with other properties\n\t * @param   { Object } src - source object\n\t * @returns { Object } the resulting extended object\n\t *\n\t * var obj = { foo: 'baz' }\n\t * extend(obj, {bar: 'bar', foo: 'bar'})\n\t * console.log(obj) => {bar: 'bar', foo: 'bar'}\n\t *\n\t */\n\tfunction extend(src) {\n\t  var obj, args = arguments;\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if (obj = args[i]) {\n\t      for (var key in obj) {\n\t        // check if this property of the source object could be overridden\n\t        if (isWritable(src, key))\n\t          { src[key] = obj[key]; }\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\tvar misc = Object.freeze({\n\t\teach: each,\n\t\tcontains: contains,\n\t\ttoCamel: toCamel,\n\t\tstartsWith: startsWith,\n\t\tdefineProperty: defineProperty,\n\t\textend: extend\n\t});\n\t\n\tvar settings$1 = extend(Object.create(brackets.settings), {\n\t  skipAnonymousTags: true\n\t});\n\t\n\t/**\n\t * Trigger DOM events\n\t * @param   { HTMLElement } dom - dom element target of the event\n\t * @param   { Function } handler - user function\n\t * @param   { Object } e - event object\n\t */\n\tfunction handleEvent(dom, handler, e) {\n\t  var ptag = this.__.parent,\n\t    item = this.__.item;\n\t\n\t  if (!item)\n\t    { while (ptag && !item) {\n\t      item = ptag.__.item;\n\t      ptag = ptag.__.parent;\n\t    } }\n\t\n\t  // override the event properties\n\t  /* istanbul ignore next */\n\t  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n\t  /* istanbul ignore next */\n\t  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n\t  /* istanbul ignore next */\n\t  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\t\n\t  e.item = item;\n\t\n\t  handler.call(this, e);\n\t\n\t  if (!e.preventUpdate) {\n\t    var p = getImmediateCustomParentTag(this);\n\t    // fixes #2083\n\t    if (p.isMounted) { p.update(); }\n\t  }\n\t}\n\t\n\t/**\n\t * Attach an event to a DOM node\n\t * @param { String } name - event name\n\t * @param { Function } handler - event callback\n\t * @param { Object } dom - dom node\n\t * @param { Tag } tag - tag instance\n\t */\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t  var eventName,\n\t    cb = handleEvent.bind(tag, dom, handler);\n\t\n\t  // normalize event name\n\t  eventName = name.replace(RE_EVENTS_PREFIX, '');\n\t\n\t  // cache the listener into the listeners array\n\t  if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n\t  if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n\t  if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\t\n\t  dom[RIOT_EVENTS_KEY][name] = cb;\n\t  dom.addEventListener(eventName, cb, false);\n\t}\n\t\n\t/**\n\t * Update dynamically created data-is tags with changing expressions\n\t * @param { Object } expr - expression tag and expression info\n\t * @param { Tag }    parent - parent for tag creation\n\t * @param { String } tagName - tag implementation we want to use\n\t */\n\tfunction updateDataIs(expr, parent, tagName) {\n\t  var conf, isVirtual, head, ref;\n\t\n\t  if (expr.tag && expr.tagName === tagName) {\n\t    expr.tag.update();\n\t    return\n\t  }\n\t\n\t  isVirtual = expr.dom.tagName === 'VIRTUAL';\n\t  // sync _parent to accommodate changing tagnames\n\t  if (expr.tag) {\n\t    // need placeholder before unmount\n\t    if(isVirtual) {\n\t      head = expr.tag.__.head;\n\t      ref = createDOMPlaceholder();\n\t      head.parentNode.insertBefore(ref, head);\n\t    }\n\t\n\t    expr.tag.unmount(true);\n\t  }\n\t\n\t  if (!isString(tagName)) { return }\n\t\n\t  expr.impl = __TAG_IMPL[tagName];\n\t  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n\t  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n\t  each(expr.attrs, function (a) { return setAttr(expr.tag.root, a.name, a.value); });\n\t  expr.tagName = tagName;\n\t  expr.tag.mount();\n\t  if (isVirtual)\n\t    { makeReplaceVirtual(expr.tag, ref || expr.tag.root); } // root exist first time, after use placeholder\n\t\n\t  // parent is the placeholder tag, not the dynamic tag so clean up\n\t  parent.__.onUnmount = function() {\n\t    var delName = expr.tag.opts.dataIs,\n\t      tags = expr.tag.parent.tags,\n\t      _tags = expr.tag.__.parent.tags;\n\t    arrayishRemove(tags, delName, expr.tag);\n\t    arrayishRemove(_tags, delName, expr.tag);\n\t    expr.tag.unmount();\n\t  };\n\t}\n\t\n\t/**\n\t * Nomalize any attribute removing the \"riot-\" prefix\n\t * @param   { String } attrName - original attribute name\n\t * @returns { String } valid html attribute name\n\t */\n\tfunction normalizeAttrName(attrName) {\n\t  if (!attrName) { return null }\n\t  attrName = attrName.replace(ATTRS_PREFIX, '');\n\t  if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n\t  return attrName\n\t}\n\t\n\t/**\n\t * Update on single tag expression\n\t * @this Tag\n\t * @param { Object } expr - expression logic\n\t * @returns { undefined }\n\t */\n\tfunction updateExpression(expr) {\n\t  if (this.root && getAttr(this.root,'virtualized')) { return }\n\t\n\t  var dom = expr.dom,\n\t    // remove the riot- prefix\n\t    attrName = normalizeAttrName(expr.attr),\n\t    isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),\n\t    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n\t    parent = dom && (expr.parent || dom.parentNode),\n\t    // detect the style attributes\n\t    isStyleAttr = attrName === 'style',\n\t    isClassAttr = attrName === 'class',\n\t    isObj,\n\t    value;\n\t\n\t  // if it's a tag we could totally skip the rest\n\t  if (expr._riot_id) {\n\t    if (expr.isMounted) {\n\t      expr.update();\n\t    // if it hasn't been mounted yet, do that now.\n\t    } else {\n\t      expr.mount();\n\t      if (isVirtual) {\n\t        makeReplaceVirtual(expr, expr.root);\n\t      }\n\t    }\n\t    return\n\t  }\n\t  // if this expression has the update method it means it can handle the DOM changes by itself\n\t  if (expr.update) { return expr.update() }\n\t\n\t  // ...it seems to be a simple expression so we try to calculat its value\n\t  value = tmpl(expr.expr, isToggle ? extend(Object.create(this.parent), this) : this);\n\t  isObj = isObject(value);\n\t\n\t  // convert the style/class objects to strings\n\t  if (isObj) {\n\t    isObj = !isClassAttr && !isStyleAttr;\n\t    if (isClassAttr) {\n\t      value = tmpl(JSON.stringify(value), this);\n\t    } else if (isStyleAttr) {\n\t      value = styleObjectToString(value);\n\t    }\n\t  }\n\t\n\t  // remove original attribute\n\t  if (expr.attr && (!expr.isAttrRemoved || !value)) {\n\t    remAttr(dom, expr.attr);\n\t    expr.isAttrRemoved = true;\n\t  }\n\t\n\t  // for the boolean attributes we don't need the value\n\t  // we can convert it to checked=true to checked=checked\n\t  if (expr.bool) { value = value ? attrName : false; }\n\t  if (expr.isRtag) { return updateDataIs(expr, this, value) }\n\t  if (expr.wasParsedOnce && expr.value === value) { return }\n\t\n\t  // update the expression value\n\t  expr.value = value;\n\t  expr.wasParsedOnce = true;\n\t\n\t  // if the value is an object we can not do much more with it\n\t  if (isObj && !isToggle) { return }\n\t  // avoid to render undefined/null values\n\t  if (isBlank(value)) { value = ''; }\n\t\n\t  // textarea and text nodes have no attribute name\n\t  if (!attrName) {\n\t    // about #815 w/o replace: the browser converts the value to a string,\n\t    // the comparison by \"==\" does too, but not in the server\n\t    value += '';\n\t    // test for parent avoids error with invalid assignment to nodeValue\n\t    if (parent) {\n\t      // cache the parent node because somehow it will become null on IE\n\t      // on the next iteration\n\t      expr.parent = parent;\n\t      if (parent.tagName === 'TEXTAREA') {\n\t        parent.value = value;                    // #1113\n\t        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n\t      }                                         // will be available on 'updated'\n\t      else { dom.nodeValue = value; }\n\t    }\n\t    return\n\t  }\n\t\n\t\n\t  // event handler\n\t  if (isFunction(value)) {\n\t    setEventHandler(attrName, value, dom, this);\n\t  // show / hide\n\t  } else if (isToggle) {\n\t    toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n\t  // handle attributes\n\t  } else {\n\t    if (expr.bool) {\n\t      dom[attrName] = value;\n\t    }\n\t\n\t    if (attrName === 'value' && dom.value !== value) {\n\t      dom.value = value;\n\t    }\n\t\n\t    if (!isBlank(value) && value !== false) {\n\t      setAttr(dom, attrName, value);\n\t    }\n\t\n\t    // make sure that in case of style changes\n\t    // the element stays hidden\n\t    if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n\t  }\n\t}\n\t\n\t/**\n\t * Update all the expressions in a Tag instance\n\t * @this Tag\n\t * @param { Array } expressions - expression that must be re evaluated\n\t */\n\tfunction updateAllExpressions(expressions) {\n\t  each(expressions, updateExpression.bind(this));\n\t}\n\t\n\tvar IfExpr = {\n\t  init: function init(dom, tag, expr) {\n\t    remAttr(dom, CONDITIONAL_DIRECTIVE);\n\t    this.tag = tag;\n\t    this.expr = expr;\n\t    this.stub = document.createTextNode('');\n\t    this.pristine = dom;\n\t\n\t    var p = dom.parentNode;\n\t    p.insertBefore(this.stub, dom);\n\t    p.removeChild(dom);\n\t\n\t    return this\n\t  },\n\t  update: function update() {\n\t    this.value = tmpl(this.expr, this.tag);\n\t\n\t    if (this.value && !this.current) { // insert\n\t      this.current = this.pristine.cloneNode(true);\n\t      this.stub.parentNode.insertBefore(this.current, this.stub);\n\t      this.expressions = [];\n\t      parseExpressions.apply(this.tag, [this.current, this.expressions, true]);\n\t    } else if (!this.value && this.current) { // remove\n\t      unmountAll(this.expressions);\n\t      if (this.current._tag) {\n\t        this.current._tag.unmount();\n\t      } else if (this.current.parentNode) {\n\t        this.current.parentNode.removeChild(this.current);\n\t      }\n\t      this.current = null;\n\t      this.expressions = [];\n\t    }\n\t\n\t    if (this.value) { updateAllExpressions.call(this.tag, this.expressions); }\n\t  },\n\t  unmount: function unmount() {\n\t    unmountAll(this.expressions || []);\n\t    delete this.pristine;\n\t    delete this.parentNode;\n\t    delete this.stub;\n\t  }\n\t};\n\t\n\tvar RefExpr = {\n\t  init: function init(dom, parent, attrName, attrValue) {\n\t    this.dom = dom;\n\t    this.attr = attrName;\n\t    this.rawValue = attrValue;\n\t    this.parent = parent;\n\t    this.hasExp = tmpl.hasExpr(attrValue);\n\t    return this\n\t  },\n\t  update: function update() {\n\t    var old = this.value;\n\t    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\t    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n\t    var tagOrDom = this.tag || this.dom;\n\t\n\t    this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\t\n\t    // the name changed, so we need to remove it from the old key (if present)\n\t    if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n\t\n\t    if (isBlank(this.value)) {\n\t      // if the value is blank, we remove it\n\t      remAttr(this.dom, this.attr);\n\t    } else {\n\t      // add it to the refs of parent tag (this behavior was changed >=3.0)\n\t      if (customParent) { arrayishAdd(\n\t        customParent.refs,\n\t        this.value,\n\t        tagOrDom,\n\t        // use an array if it's a looped node and the ref is not an expression\n\t        null,\n\t        this.parent.__.index\n\t      ); }\n\t      // set the actual DOM attr\n\t      setAttr(this.dom, this.attr, this.value);\n\t    }\n\t  },\n\t  unmount: function unmount() {\n\t    var tagOrDom = this.tag || this.dom;\n\t    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\t    if (!isBlank(this.value) && customParent)\n\t      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\t    delete this.dom;\n\t    delete this.parent;\n\t  }\n\t};\n\t\n\t/**\n\t * Convert the item looped into an object used to extend the child tag properties\n\t * @param   { Object } expr - object containing the keys used to extend the children tags\n\t * @param   { * } key - value to assign to the new object returned\n\t * @param   { * } val - value containing the position of the item in the array\n\t * @param   { Object } base - prototype object for the new item\n\t * @returns { Object } - new object containing the values of the original item\n\t *\n\t * The variables 'key' and 'val' are arbitrary.\n\t * They depend on the collection type looped (Array, Object)\n\t * and on the expression used on the each tag\n\t *\n\t */\n\tfunction mkitem(expr, key, val, base) {\n\t  var item = base ? Object.create(base) : {};\n\t  item[expr.key] = key;\n\t  if (expr.pos) { item[expr.pos] = val; }\n\t  return item\n\t}\n\t\n\t/**\n\t * Unmount the redundant tags\n\t * @param   { Array } items - array containing the current items to loop\n\t * @param   { Array } tags - array containing all the children tags\n\t */\n\tfunction unmountRedundant(items, tags) {\n\t  var i = tags.length,\n\t    j = items.length;\n\t\n\t  while (i > j) {\n\t    i--;\n\t    remove.apply(tags[i], [tags, i]);\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Remove a child tag\n\t * @this Tag\n\t * @param   { Array } tags - tags collection\n\t * @param   { Number } i - index of the tag to remove\n\t */\n\tfunction remove(tags, i) {\n\t  tags.splice(i, 1);\n\t  this.unmount();\n\t  arrayishRemove(this.parent, this, this.__.tagName, true);\n\t}\n\t\n\t/**\n\t * Move the nested custom tags in non custom loop tags\n\t * @this Tag\n\t * @param   { Number } i - current position of the loop tag\n\t */\n\tfunction moveNestedTags(i) {\n\t  var this$1 = this;\n\t\n\t  each(Object.keys(this.tags), function (tagName) {\n\t    moveChildTag.apply(this$1.tags[tagName], [tagName, i]);\n\t  });\n\t}\n\t\n\t/**\n\t * Move a child tag\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction move(root, nextTag, isVirtual) {\n\t  if (isVirtual)\n\t    { moveVirtual.apply(this, [root, nextTag]); }\n\t  else\n\t    { safeInsert(root, this.root, nextTag.root); }\n\t}\n\t\n\t/**\n\t * Insert and mount a child tag\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction insert(root, nextTag, isVirtual) {\n\t  if (isVirtual)\n\t    { makeVirtual.apply(this, [root, nextTag]); }\n\t  else\n\t    { safeInsert(root, this.root, nextTag.root); }\n\t}\n\t\n\t/**\n\t * Append a new tag into the DOM\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction append(root, isVirtual) {\n\t  if (isVirtual)\n\t    { makeVirtual.call(this, root); }\n\t  else\n\t    { root.appendChild(this.root); }\n\t}\n\t\n\t/**\n\t * Manage tags having the 'each'\n\t * @param   { HTMLElement } dom - DOM node we need to loop\n\t * @param   { Tag } parent - parent tag instance where the dom node is contained\n\t * @param   { String } expr - string contained in the 'each' attribute\n\t * @returns { Object } expression object for this each loop\n\t */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  // remove the each property from the original tag\n\t  remAttr(dom, LOOP_DIRECTIVE);\n\t\n\t  var mustReorder = typeof getAttr(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE),\n\t    tagName = getTagName(dom),\n\t    impl = __TAG_IMPL[tagName],\n\t    parentNode = dom.parentNode,\n\t    placeholder = createDOMPlaceholder(),\n\t    child = getTag(dom),\n\t    ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE),\n\t    tags = [],\n\t    oldItems = [],\n\t    hasKeys,\n\t    isLoop = true,\n\t    isAnonymous = !__TAG_IMPL[tagName],\n\t    isVirtual = dom.tagName === 'VIRTUAL';\n\t\n\t  // parse the each expression\n\t  expr = tmpl.loopKeys(expr);\n\t  expr.isLoop = true;\n\t\n\t  if (ifExpr) { remAttr(dom, CONDITIONAL_DIRECTIVE); }\n\t\n\t  // insert a marked where the loop tags will be injected\n\t  parentNode.insertBefore(placeholder, dom);\n\t  parentNode.removeChild(dom);\n\t\n\t  expr.update = function updateEach() {\n\t    // get the new items collection\n\t    expr.value = tmpl(expr.val, parent);\n\t\n\t    var frag = createFrag(),\n\t      items = expr.value,\n\t      isObject$$1 = !isArray(items) && !isString(items),\n\t      root = placeholder.parentNode;\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (isObject$$1) {\n\t      hasKeys = items || false;\n\t      items = hasKeys ?\n\t        Object.keys(items).map(function (key) {\n\t          return mkitem(expr, items[key], key)\n\t        }) : [];\n\t    } else {\n\t      hasKeys = false;\n\t    }\n\t\n\t    if (ifExpr) {\n\t      items = items.filter(function(item, i) {\n\t        if (expr.key && !isObject$$1)\n\t          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\t\n\t        return !!tmpl(ifExpr, extend(Object.create(parent), item))\n\t      });\n\t    }\n\t\n\t    // loop all the new items\n\t    each(items, function(item, i) {\n\t      // reorder only if the items are objects\n\t      var\n\t        doReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n\t        oldPos = oldItems.indexOf(item),\n\t        isNew = oldPos === -1,\n\t        pos = !isNew && doReorder ? oldPos : i,\n\t        // does a tag exist in this position?\n\t        tag = tags[pos],\n\t        mustAppend = i >= oldItems.length,\n\t        mustCreate =  doReorder && isNew || !doReorder && !tag;\n\t\n\t      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\t\n\t      // new tag\n\t      if (mustCreate) {\n\t        tag = new Tag$1(impl, {\n\t          parent: parent,\n\t          isLoop: isLoop,\n\t          isAnonymous: isAnonymous,\n\t          tagName: tagName,\n\t          root: dom.cloneNode(isAnonymous),\n\t          item: item,\n\t          index: i,\n\t        }, dom.innerHTML);\n\t\n\t        // mount the tag\n\t        tag.mount();\n\t\n\t        if (mustAppend)\n\t          { append.apply(tag, [frag || root, isVirtual]); }\n\t        else\n\t          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\t\n\t        if (!mustAppend) { oldItems.splice(i, 0, item); }\n\t        tags.splice(i, 0, tag);\n\t        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n\t      } else if (pos !== i && doReorder) {\n\t        // move\n\t        if (contains(items, oldItems[pos])) {\n\t          move.apply(tag, [root, tags[i], isVirtual]);\n\t          // move the old tag instance\n\t          tags.splice(i, 0, tags.splice(pos, 1)[0]);\n\t          // move the old item\n\t          oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n\t        }\n\t\n\t        // update the position attribute if it exists\n\t        if (expr.pos) { tag[expr.pos] = i; }\n\t\n\t        // if the loop tags are not custom\n\t        // we need to move all their custom tags into the right position\n\t        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n\t      }\n\t\n\t      // cache the original item to use it in the events bound to this node\n\t      // and its children\n\t      tag.__.item = item;\n\t      tag.__.index = i;\n\t      tag.__.parent = parent;\n\t\n\t      if (!mustCreate) { tag.update(item); }\n\t    });\n\t\n\t    // remove the redundant tags\n\t    unmountRedundant(items, tags);\n\t\n\t    // clone the items array\n\t    oldItems = items.slice();\n\t\n\t    root.insertBefore(frag, placeholder);\n\t  };\n\t\n\t  expr.unmount = function() {\n\t    each(tags, function(t) { t.unmount(); });\n\t  };\n\t\n\t  return expr\n\t}\n\t\n\t/**\n\t * Walk the tag DOM to detect the expressions to evaluate\n\t * @this Tag\n\t * @param   { HTMLElement } root - root tag where we will start digging the expressions\n\t * @param   { Array } expressions - empty array where the expressions will be added\n\t * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n\t * @returns { Object } an object containing the root noode and the dom tree\n\t */\n\tfunction parseExpressions(root, expressions, mustIncludeRoot) {\n\t  var this$1 = this;\n\t\n\t  var tree = {parent: {children: expressions}};\n\t\n\t  walkNodes(root, function (dom, ctx) {\n\t    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n\t    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\t\n\t    // text node\n\t    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n\t      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\t\n\t    if (type !== 1) { return ctx } // not an element\n\t\n\t    var isVirtual = dom.tagName === 'VIRTUAL';\n\t\n\t    // loop. each does it's own thing (for now)\n\t    if (attr = getAttr(dom, LOOP_DIRECTIVE)) {\n\t      if(isVirtual) { setAttr(dom, 'loopVirtual', true); } // ignore here, handled in _each\n\t      parent.children.push(_each(dom, this$1, attr));\n\t      return false\n\t    }\n\t\n\t    // if-attrs become the new parent. Any following expressions (either on the current\n\t    // element, or below it) become children of this expression.\n\t    if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {\n\t      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n\t      return false\n\t    }\n\t\n\t    if (expr = getAttr(dom, IS_DIRECTIVE)) {\n\t      if (tmpl.hasExpr(expr)) {\n\t        parent.children.push({isRtag: true, expr: expr, dom: dom, attrs: [].slice.call(dom.attributes)});\n\t        return false\n\t      }\n\t    }\n\t\n\t    // if this is a tag, stop traversing here.\n\t    // we ignore the root, since parseExpressions is called while we're mounting that root\n\t    tagImpl = getTag(dom);\n\t    if(isVirtual) {\n\t      if(getAttr(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n\t      if(!tagImpl && !getAttr(dom, 'virtualized') && !getAttr(dom, 'loopVirtual'))  // ok to create virtual tag\n\t        { tagImpl = { tmpl: dom.outerHTML }; }\n\t    }\n\t\n\t    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n\t      if(isVirtual && !getAttr(dom, IS_DIRECTIVE)) { // handled in update\n\t        // can not remove attribute like directives\n\t        // so flag for removal after creation to prevent maximum stack error\n\t        setAttr(dom, 'virtualized', true);\n\t\n\t        var tag = new Tag$1({ tmpl: dom.outerHTML },\n\t          {root: dom, parent: this$1},\n\t          dom.innerHTML);\n\t        parent.children.push(tag); // no return, anonymous tag, keep parsing\n\t      } else {\n\t        var conf = {root: dom, parent: this$1, hasImpl: true};\n\t        parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n\t        return false\n\t      }\n\t    }\n\t\n\t    // attribute expressions\n\t    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n\t      if (!expr) { return }\n\t      parent.children.push(expr);\n\t    }]);\n\t\n\t    // whatever the parent is, all child elements get the same parent.\n\t    // If this element had an if-attr, that's the parent for all child elements\n\t    return {parent: parent}\n\t  }, tree);\n\t}\n\t\n\t/**\n\t * Calls `fn` for every attribute on an element. If that attr has an expression,\n\t * it is also passed to fn.\n\t * @this Tag\n\t * @param   { HTMLElement } dom - dom node to parse\n\t * @param   { Array } attrs - array of attributes\n\t * @param   { Function } fn - callback to exec on any iteration\n\t */\n\tfunction parseAttributes(dom, attrs, fn) {\n\t  var this$1 = this;\n\t\n\t  each(attrs, function (attr) {\n\t    var name = attr.name, bool = isBoolAttr(name), expr;\n\t\n\t    if (contains(REF_DIRECTIVES, name)) {\n\t      expr =  Object.create(RefExpr).init(dom, this$1, name, attr.value);\n\t    } else if (tmpl.hasExpr(attr.value)) {\n\t      expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n\t    }\n\t\n\t    fn(attr, expr);\n\t  });\n\t}\n\t\n\t/*\n\t  Includes hacks needed for the Internet Explorer version 9 and below\n\t  See: http://kangax.github.io/compat-table/es5/#ie8\n\t       http://codeplanet.io/dropping-ie8/\n\t*/\n\t\n\tvar reHasYield  = /<yield\\b/i;\n\tvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\n\tvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\n\tvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\n\tvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\n\tvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\n\tvar GENERIC = 'div';\n\t\n\t\n\t/*\n\t  Creates the root element for table or select child elements:\n\t  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n\t*/\n\tfunction specialTags(el, tmpl, tagName) {\n\t\n\t  var\n\t    select = tagName[0] === 'o',\n\t    parent = select ? 'select>' : 'table>';\n\t\n\t  // trim() is important here, this ensures we don't have artifacts,\n\t  // so we can check if we have only one element inside the parent\n\t  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n\t  parent = el.firstChild;\n\t\n\t  // returns the immediate parent if tr/th/td/col is the only element, if not\n\t  // returns the whole tree, as this can include additional elements\n\t  /* istanbul ignore next */\n\t  if (select) {\n\t    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n\t  } else {\n\t    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n\t    var tname = rootEls[tagName];\n\t    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n\t  }\n\t  return parent\n\t}\n\t\n\t/*\n\t  Replace the yield tag from any tag template with the innerHTML of the\n\t  original tag in the page\n\t*/\n\tfunction replaceYield(tmpl, html) {\n\t  // do nothing if no yield\n\t  if (!reHasYield.test(tmpl)) { return tmpl }\n\t\n\t  // be careful with #1343 - string on the source having `$1`\n\t  var src = {};\n\t\n\t  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n\t    src[ref] = src[ref] || text;   // preserve first definition\n\t    return ''\n\t  }).trim();\n\t\n\t  return tmpl\n\t    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n\t      return src[ref] || def || ''\n\t    })\n\t    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n\t      return html || def || ''\n\t    })\n\t}\n\t\n\t/**\n\t * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n\t * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n\t *\n\t * @param   { String } tmpl  - The template coming from the custom tag definition\n\t * @param   { String } html - HTML content that comes from the DOM element where you\n\t *           will mount the tag, mostly the original tag in the page\n\t * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n\t */\n\tfunction mkdom(tmpl, html) {\n\t  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n\t    tagName = match && match[1].toLowerCase(),\n\t    el = mkEl(GENERIC);\n\t\n\t  // replace all the yield tags with the tag inner html\n\t  tmpl = replaceYield(tmpl, html);\n\t\n\t  /* istanbul ignore next */\n\t  if (tblTags.test(tagName))\n\t    { el = specialTags(el, tmpl, tagName); }\n\t  else\n\t    { setInnerHTML(el, tmpl); }\n\t\n\t  return el\n\t}\n\t\n\t/**\n\t * Another way to create a riot tag a bit more es6 friendly\n\t * @param { HTMLElement } el - tag DOM selector or DOM node/s\n\t * @param { Object } opts - tag logic\n\t * @returns { Tag } new riot tag instance\n\t */\n\tfunction Tag$2(el, opts) {\n\t  // get the tag properties from the class constructor\n\t  var ref = this;\n\t  var name = ref.name;\n\t  var tmpl = ref.tmpl;\n\t  var css = ref.css;\n\t  var attrs = ref.attrs;\n\t  var onCreate = ref.onCreate;\n\t  // register a new tag and cache the class prototype\n\t  if (!__TAG_IMPL[name]) {\n\t    tag$1(name, tmpl, css, attrs, onCreate);\n\t    // cache the class constructor\n\t    __TAG_IMPL[name].class = this.constructor;\n\t  }\n\t\n\t  // mount the tag using the class instance\n\t  mountTo(el, name, opts, this);\n\t  // inject the component css\n\t  if (css) { styleManager.inject(); }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   tmpl - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\tfunction tag$1(name, tmpl, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs;\n\t\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css;\n\t      css = '';\n\t    } else\n\t      { attrs = ''; }\n\t  }\n\t\n\t  if (css) {\n\t    if (isFunction(css))\n\t      { fn = css; }\n\t    else\n\t      { styleManager.add(css); }\n\t  }\n\t\n\t  name = name.toLowerCase();\n\t  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\t\n\t  return name\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation (for use by the compiler)\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   tmpl - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\tfunction tag2$1(name, tmpl, css, attrs, fn) {\n\t  if (css) { styleManager.add(css, name); }\n\t\n\t  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\t\n\t  return name\n\t}\n\t\n\t/**\n\t * Mount a tag using a specific tag implementation\n\t * @param   { * } selector - tag DOM selector or DOM node/s\n\t * @param   { String } tagName - tag implementation name\n\t * @param   { Object } opts - tag logic\n\t * @returns { Array } new tags instances\n\t */\n\tfunction mount$1(selector, tagName, opts) {\n\t  var tags = [];\n\t\n\t  function pushTagsTo(root) {\n\t    if (root.tagName) {\n\t      var riotTag = getAttr(root, IS_DIRECTIVE);\n\t\n\t      // have tagName? force riot-tag to be the same\n\t      if (tagName && riotTag !== tagName) {\n\t        riotTag = tagName;\n\t        setAttr(root, IS_DIRECTIVE, tagName);\n\t      }\n\t\n\t      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\t\n\t      if (tag)\n\t        { tags.push(tag); }\n\t    } else if (root.length)\n\t      { each(root, pushTagsTo); } // assume nodeList\n\t  }\n\t\n\t  // inject styles into DOM\n\t  styleManager.inject();\n\t\n\t  if (isObject(tagName)) {\n\t    opts = tagName;\n\t    tagName = 0;\n\t  }\n\t\n\t  var elem;\n\t  var allTags;\n\t\n\t  // crawl the DOM to find the tag\n\t  if (isString(selector)) {\n\t    selector = selector === '*' ?\n\t      // select all registered tags\n\t      // & tags found with the riot-tag attribute set\n\t      allTags = selectTags() :\n\t      // or just the ones named like the selector\n\t      selector + selectTags(selector.split(/, */));\n\t\n\t    // make sure to pass always a selector\n\t    // to the querySelectorAll function\n\t    elem = selector ? $$(selector) : [];\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    { elem = selector; }\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectTags();\n\t    // if the root els it's just a single tag\n\t    if (elem.tagName)\n\t      { elem = $$(tagName, elem); }\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = [];\n\t\n\t      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\t\n\t      elem = nodeList;\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0;\n\t  }\n\t\n\t  pushTagsTo(elem);\n\t\n\t  return tags\n\t}\n\t\n\t// Create a mixin that could be globally shared across all the tags\n\tvar mixins = {};\n\tvar globals = mixins[GLOBAL_MIXIN] = {};\n\tvar mixins_id = 0;\n\t\n\t/**\n\t * Create/Return a mixin by its name\n\t * @param   { String }  name - mixin name (global mixin if object)\n\t * @param   { Object }  mix - mixin logic\n\t * @param   { Boolean } g - is global?\n\t * @returns { Object }  the mixin logic\n\t */\n\tfunction mixin$1(name, mix, g) {\n\t  // Unnamed global\n\t  if (isObject(name)) {\n\t    mixin$1((\"__unnamed_\" + (mixins_id++)), name, true);\n\t    return\n\t  }\n\t\n\t  var store = g ? globals : mixins;\n\t\n\t  // Getter\n\t  if (!mix) {\n\t    if (isUndefined(store[name]))\n\t      { throw new Error('Unregistered mixin: ' + name) }\n\t\n\t    return store[name]\n\t  }\n\t\n\t  // Setter\n\t  store[name] = isFunction(mix) ?\n\t    extend(mix.prototype, store[name] || {}) && mix :\n\t    extend(store[name] || {}, mix);\n\t}\n\t\n\t/**\n\t * Update all the tags instances created\n\t * @returns { Array } all the tags instances\n\t */\n\tfunction update$1() {\n\t  return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n\t}\n\t\n\tfunction unregister$1(name) {\n\t  delete __TAG_IMPL[name];\n\t}\n\t\n\tvar version$1 = 'v3.4.3';\n\t\n\t\n\tvar core = Object.freeze({\n\t\tTag: Tag$2,\n\t\ttag: tag$1,\n\t\ttag2: tag2$1,\n\t\tmount: mount$1,\n\t\tmixin: mixin$1,\n\t\tupdate: update$1,\n\t\tunregister: unregister$1,\n\t\tversion: version$1\n\t});\n\t\n\t// counter to give a unique id to all the Tag instances\n\tvar __uid = 0;\n\t\n\t/**\n\t * We need to update opts for this tag. That requires updating the expressions\n\t * in any attributes on the tag, and then copying the result onto opts.\n\t * @this Tag\n\t * @param   {Boolean} isLoop - is it a loop tag?\n\t * @param   { Tag }  parent - parent tag node\n\t * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n\t * @param   { Object }  opts - tag options\n\t * @param   { Array }  instAttrs - tag attributes array\n\t */\n\tfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n\t  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n\t  // (and only this case) we don't need to do updateOpts, because the regular parse\n\t  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n\t  if (isLoop && isAnonymous) { return }\n\t\n\t  var ctx = !isAnonymous && isLoop ? this : parent || this;\n\t  each(instAttrs, function (attr) {\n\t    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n\t    // normalize the attribute names\n\t    opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n\t  });\n\t}\n\t\n\t\n\t/**\n\t * Tag class\n\t * @constructor\n\t * @param { Object } impl - it contains the tag template, and logic\n\t * @param { Object } conf - tag options\n\t * @param { String } innerHTML - html that eventually we need to inject in the tag\n\t */\n\tfunction Tag$1(impl, conf, innerHTML) {\n\t  if ( impl === void 0 ) impl = {};\n\t  if ( conf === void 0 ) conf = {};\n\t\n\t  var opts = extend({}, conf.opts),\n\t    parent = conf.parent,\n\t    isLoop = conf.isLoop,\n\t    isAnonymous = !!conf.isAnonymous,\n\t    skipAnonymous = settings$1.skipAnonymousTags && isAnonymous,\n\t    item = cleanUpData(conf.item),\n\t    index = conf.index, // available only for the looped nodes\n\t    instAttrs = [], // All attributes on the Tag when it's first parsed\n\t    implAttrs = [], // expressions on this type of Tag\n\t    expressions = [],\n\t    root = conf.root,\n\t    tagName = conf.tagName || getTagName(root),\n\t    isVirtual = tagName === 'virtual',\n\t    propsInSyncWithParent = [],\n\t    dom;\n\t\n\t  // make this tag observable\n\t  if (!skipAnonymous) { observable$1(this); }\n\t  // only call unmount if we have a valid __TAG_IMPL (has name property)\n\t  if (impl.name && root._tag) { root._tag.unmount(true); }\n\t\n\t  // not yet mounted\n\t  this.isMounted = false;\n\t\n\t  defineProperty(this, '__', {\n\t    isAnonymous: isAnonymous,\n\t    instAttrs: instAttrs,\n\t    innerHTML: innerHTML,\n\t    tagName: tagName,\n\t    index: index,\n\t    isLoop: isLoop,\n\t    // tags having event listeners\n\t    // it would be better to use weak maps here but we can not introduce breaking changes now\n\t    listeners: [],\n\t    // these vars will be needed only for the virtual tags\n\t    virts: [],\n\t    tail: null,\n\t    head: null,\n\t    parent: null,\n\t    item: null\n\t  });\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n\t  defineProperty(this, 'root', root);\n\t  extend(this, { opts: opts }, item);\n\t  // protect the \"tags\" and \"refs\" property from being overridden\n\t  defineProperty(this, 'parent', parent || null);\n\t  defineProperty(this, 'tags', {});\n\t  defineProperty(this, 'refs', {});\n\t\n\t  dom = isLoop && isAnonymous ? root : mkdom(impl.tmpl, innerHTML, isLoop);\n\t\n\t  /**\n\t   * Update the tag expressions and options\n\t   * @param   { * }  data - data we want to use to extend the tag properties\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'update', function tagUpdate(data) {\n\t    var nextOpts = {},\n\t      canTrigger = this.isMounted && !skipAnonymous;\n\t\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data);\n\t    extend(this, data);\n\t    updateOpts.apply(this, [isLoop, parent, isAnonymous, nextOpts, instAttrs]);\n\t\n\t    if (canTrigger && this.isMounted && isFunction(this.shouldUpdate) && !this.shouldUpdate(data, nextOpts)) {\n\t      return this\n\t    }\n\t\n\t    // inherit properties from the parent, but only for isAnonymous tags\n\t    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n\t    extend(opts, nextOpts);\n\t    if (canTrigger) { this.trigger('update', data); }\n\t    updateAllExpressions.call(this, expressions);\n\t    if (canTrigger) { this.trigger('updated'); }\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Add a mixin to this tag\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'mixin', function tagMixin() {\n\t    var this$1 = this;\n\t\n\t    each(arguments, function (mix) {\n\t      var instance, obj;\n\t      var props = [];\n\t\n\t      // properties blacklisted and will not be bound to the tag instance\n\t      var propsBlacklist = ['init', '__proto__'];\n\t\n\t      mix = isString(mix) ? mixin$1(mix) : mix;\n\t\n\t      // check if the mixin is a function\n\t      if (isFunction(mix)) {\n\t        // create the new mixin instance\n\t        instance = new mix();\n\t      } else { instance = mix; }\n\t\n\t      var proto = Object.getPrototypeOf(instance);\n\t\n\t      // build multilevel prototype inheritance chain property list\n\t      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n\t      while (obj = Object.getPrototypeOf(obj || instance))\n\t\n\t      // loop the keys in the function prototype or the all object keys\n\t      each(props, function (key) {\n\t        // bind methods to this\n\t        // allow mixins to override other properties/parent mixins\n\t        if (!contains(propsBlacklist, key)) {\n\t          // check for getters/setters\n\t          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n\t          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\t\n\t          // apply method only if it does not already exist on the instance\n\t          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n\t            Object.defineProperty(this$1, key, descriptor);\n\t          } else {\n\t            this$1[key] = isFunction(instance[key]) ?\n\t              instance[key].bind(this$1) :\n\t              instance[key];\n\t          }\n\t        }\n\t      });\n\t\n\t      // init method will be called automatically\n\t      if (instance.init)\n\t        { instance.init.bind(this$1)(); }\n\t    });\n\t    return this\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Mount the current tag instance\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'mount', function tagMount() {\n\t    var this$1 = this;\n\t\n\t    root._tag = this; // keep a reference to the tag just created\n\t\n\t    // Read all the attrs on this instance. This give us the info we need for updateOpts\n\t    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n\t      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n\t      attr.expr = expr;\n\t      instAttrs.push(attr);\n\t    }]);\n\t\n\t    // update the root adding custom attributes coming from the compiler\n\t    implAttrs = [];\n\t    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n\t    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n\t      if (expr) { expressions.push(expr); }\n\t      else { setAttr(root, attr.name, attr.value); }\n\t    }]);\n\t\n\t    // initialiation\n\t    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\t\n\t    // add global mixins\n\t    var globalMixin = mixin$1(GLOBAL_MIXIN);\n\t\n\t    if (globalMixin && !skipAnonymous) {\n\t      for (var i in globalMixin) {\n\t        if (globalMixin.hasOwnProperty(i)) {\n\t          this$1.mixin(globalMixin[i]);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (impl.fn) { impl.fn.call(this, opts); }\n\t\n\t    if (!skipAnonymous) { this.trigger('before-mount'); }\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions.apply(this, [dom, expressions, isAnonymous]);\n\t\n\t    this.update(item);\n\t\n\t    if (!isAnonymous) {\n\t      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n\t    }\n\t\n\t    defineProperty(this, 'root', root);\n\t    defineProperty(this, 'isMounted', true);\n\t\n\t    if (skipAnonymous) { return }\n\t\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!this.parent) {\n\t      this.trigger('mount');\n\t    }\n\t    // otherwise we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n\t    else {\n\t      var p = getImmediateCustomParentTag(this.parent);\n\t      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n\t        this$1.trigger('mount');\n\t      });\n\t    }\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Unmount the tag instance\n\t   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n\t    var this$1 = this;\n\t\n\t    var el = this.root,\n\t      p = el.parentNode,\n\t      ptag,\n\t      tagIndex = __TAGS_CACHE.indexOf(this);\n\t\n\t    if (!skipAnonymous) { this.trigger('before-unmount'); }\n\t\n\t    // clear all attributes coming from the mounted tag\n\t    walkAttrs(impl.attrs, function (name) {\n\t      if (startsWith(name, ATTRS_PREFIX))\n\t        { name = name.slice(ATTRS_PREFIX.length); }\n\t      remAttr(root, name);\n\t    });\n\t\n\t    // remove all the event listeners\n\t    this.__.listeners.forEach(function (dom) {\n\t      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n\t        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n\t      });\n\t    });\n\t\n\t    // remove this tag instance from the global virtualDom variable\n\t    if (tagIndex !== -1)\n\t      { __TAGS_CACHE.splice(tagIndex, 1); }\n\t\n\t    if (p || isVirtual) {\n\t      if (parent) {\n\t        ptag = getImmediateCustomParentTag(parent);\n\t\n\t        if (isVirtual) {\n\t          Object.keys(this.tags).forEach(function (tagName) {\n\t            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n\t          });\n\t        } else {\n\t          arrayishRemove(ptag.tags, tagName, this);\n\t          if(parent !== ptag) // remove from _parent too\n\t            { arrayishRemove(parent.tags, tagName, this); }\n\t        }\n\t      } else {\n\t        // remove the tag contents\n\t        setInnerHTML(el, '');\n\t      }\n\t\n\t      if (p && !mustKeepRoot) { p.removeChild(el); }\n\t    }\n\t\n\t    if (this.__.virts) {\n\t      each(this.__.virts, function (v) {\n\t        if (v.parentNode) { v.parentNode.removeChild(v); }\n\t      });\n\t    }\n\t\n\t    // allow expressions to unmount themselves\n\t    unmountAll(expressions);\n\t    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\t\n\t    // custom internal unmount function to avoid relying on the observable\n\t    if (this.__.onUnmount) { this.__.onUnmount(); }\n\t\n\t    if (!skipAnonymous) {\n\t      this.trigger('unmount');\n\t      this.off('*');\n\t    }\n\t\n\t    defineProperty(this, 'isMounted', false);\n\t\n\t    delete this.root._tag;\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t}\n\t\n\t/**\n\t * Detect the tag implementation by a DOM node\n\t * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n\t * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n\t */\n\tfunction getTag(dom) {\n\t  return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) ||\n\t    getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n\t}\n\t\n\t/**\n\t * Inherit properties from a target tag instance\n\t * @this Tag\n\t * @param   { Tag } target - tag where we will inherit properties\n\t * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n\t */\n\tfunction inheritFrom(target, propsInSyncWithParent) {\n\t  var this$1 = this;\n\t\n\t  each(Object.keys(target), function (k) {\n\t    // some properties must be always in sync with the parent tag\n\t    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\t\n\t    if (isUndefined(this$1[k]) || mustSync) {\n\t      // track the property to keep in sync\n\t      // so we can keep it updated\n\t      if (!mustSync) { propsInSyncWithParent.push(k); }\n\t      this$1[k] = target[k];\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Move the position of a custom tag in its parent tag\n\t * @this Tag\n\t * @param   { String } tagName - key where the tag was stored\n\t * @param   { Number } newPos - index where the new tag will be stored\n\t */\n\tfunction moveChildTag(tagName, newPos) {\n\t  var parent = this.parent,\n\t    tags;\n\t  // no parent no move\n\t  if (!parent) { return }\n\t\n\t  tags = parent.tags[tagName];\n\t\n\t  if (isArray(tags))\n\t    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n\t  else { arrayishAdd(parent.tags, tagName, this); }\n\t}\n\t\n\t/**\n\t * Create a new child tag including it correctly into its parent\n\t * @param   { Object } child - child tag implementation\n\t * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n\t * @param   { String } innerHTML - inner html of the child node\n\t * @param   { Object } parent - instance of the parent tag including the child custom tag\n\t * @returns { Object } instance of the new child tag just created\n\t */\n\tfunction initChildTag(child, opts, innerHTML, parent) {\n\t  var tag = new Tag$1(child, opts, innerHTML),\n\t    tagName = opts.tagName || getTagName(opts.root, true),\n\t    ptag = getImmediateCustomParentTag(parent);\n\t  // fix for the parent attribute in the looped elements\n\t  defineProperty(tag, 'parent', ptag);\n\t  // store the real parent tag\n\t  // in some cases this could be different from the custom parent tag\n\t  // for example in nested loops\n\t  tag.__.parent = parent;\n\t\n\t  // add this tag to the custom parent tag\n\t  arrayishAdd(ptag.tags, tagName, tag);\n\t\n\t  // and also to the real parent tag\n\t  if (ptag !== parent)\n\t    { arrayishAdd(parent.tags, tagName, tag); }\n\t\n\t  // empty the child node once we got its template\n\t  // to avoid that its children get compiled multiple times\n\t  opts.root.innerHTML = '';\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * Loop backward all the parents tree to detect the first custom parent tag\n\t * @param   { Object } tag - a Tag instance\n\t * @returns { Object } the instance of the first custom parent tag found\n\t */\n\tfunction getImmediateCustomParentTag(tag) {\n\t  var ptag = tag;\n\t  while (ptag.__.isAnonymous) {\n\t    if (!ptag.parent) { break }\n\t    ptag = ptag.parent;\n\t  }\n\t  return ptag\n\t}\n\t\n\t/**\n\t * Trigger the unmount method on all the expressions\n\t * @param   { Array } expressions - DOM expressions\n\t */\n\tfunction unmountAll(expressions) {\n\t  each(expressions, function(expr) {\n\t    if (expr instanceof Tag$1) { expr.unmount(true); }\n\t    else if (expr.tagName) { expr.tag.unmount(true); }\n\t    else if (expr.unmount) { expr.unmount(); }\n\t  });\n\t}\n\t\n\t/**\n\t * Get the tag name of any DOM node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n\t * @returns { String } name to identify this dom node in riot\n\t */\n\tfunction getTagName(dom, skipDataIs) {\n\t  var child = getTag(dom),\n\t    namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);\n\t  return namedTag && !tmpl.hasExpr(namedTag) ?\n\t                namedTag :\n\t              child ? child.name : dom.tagName.toLowerCase()\n\t}\n\t\n\t/**\n\t * With this function we avoid that the internal Tag methods get overridden\n\t * @param   { Object } data - options we want to use to extend the tag instance\n\t * @returns { Object } clean object without containing the riot internal reserved words\n\t */\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag$1) && !(data && isFunction(data.trigger)))\n\t    { return data }\n\t\n\t  var o = {};\n\t  for (var key in data) {\n\t    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n\t  }\n\t  return o\n\t}\n\t\n\t/**\n\t * Set the property of an object for a given key. If something already\n\t * exists there, then it becomes an array containing both the old and new value.\n\t * @param { Object } obj - object on which to set the property\n\t * @param { String } key - property name\n\t * @param { Object } value - the value of the property to be set\n\t * @param { Boolean } ensureArray - ensure that the property remains an array\n\t * @param { Number } index - add the new item in a certain array position\n\t */\n\tfunction arrayishAdd(obj, key, value, ensureArray, index) {\n\t  var dest = obj[key];\n\t  var isArr = isArray(dest);\n\t  var hasIndex = !isUndefined(index);\n\t\n\t  if (dest && dest === value) { return }\n\t\n\t  // if the key was never set, set it once\n\t  if (!dest && ensureArray) { obj[key] = [value]; }\n\t  else if (!dest) { obj[key] = value; }\n\t  // if it was an array and not yet set\n\t  else {\n\t    if (isArr) {\n\t      var oldIndex = dest.indexOf(value);\n\t      // this item never changed its position\n\t      if (oldIndex === index) { return }\n\t      // remove the item from its old position\n\t      if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n\t      // move or add the item\n\t      if (hasIndex) {\n\t        dest.splice(index, 0, value);\n\t      } else {\n\t        dest.push(value);\n\t      }\n\t    } else { obj[key] = [dest, value]; }\n\t  }\n\t}\n\t\n\t/**\n\t * Removes an item from an object at a given key. If the key points to an array,\n\t * then the item is just removed from the array.\n\t * @param { Object } obj - object on which to remove the property\n\t * @param { String } key - property name\n\t * @param { Object } value - the value of the property to be removed\n\t * @param { Boolean } ensureArray - ensure that the property remains an array\n\t*/\n\tfunction arrayishRemove(obj, key, value, ensureArray) {\n\t  if (isArray(obj[key])) {\n\t    var index = obj[key].indexOf(value);\n\t    if (index !== -1) { obj[key].splice(index, 1); }\n\t    if (!obj[key].length) { delete obj[key]; }\n\t    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n\t  } else\n\t    { delete obj[key]; } // otherwise just delete the key\n\t}\n\t\n\t/**\n\t * Mount a tag creating new Tag instance\n\t * @param   { Object } root - dom node where the tag will be mounted\n\t * @param   { String } tagName - name of the riot tag we want to mount\n\t * @param   { Object } opts - options to pass to the Tag instance\n\t * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n\t * @returns { Tag } a new Tag instance\n\t */\n\tfunction mountTo(root, tagName, opts, ctx) {\n\t  var impl = __TAG_IMPL[tagName],\n\t    implClass = __TAG_IMPL[tagName].class,\n\t    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n\t    // cache the inner HTML to fix #855\n\t    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\t\n\t  // clear the inner html\n\t  root.innerHTML = '';\n\t\n\t  var conf = extend({ root: root, opts: opts }, { parent: opts ? opts.parent : null });\n\t\n\t  if (impl && root) { Tag$1.apply(tag, [impl, conf, innerHTML]); }\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount(true);\n\t    // add this tag to the virtualDom variable\n\t    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n\t  }\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * makes a tag virtual and replaces a reference in the dom\n\t * @this Tag\n\t * @param { tag } the tag to make virtual\n\t * @param { ref } the dom reference location\n\t */\n\tfunction makeReplaceVirtual(tag, ref) {\n\t  var frag = createFrag();\n\t  makeVirtual.call(tag, frag);\n\t  ref.parentNode.replaceChild(frag, ref);\n\t}\n\t\n\t/**\n\t * Adds the elements for a virtual tag\n\t * @this Tag\n\t * @param { Node } src - the node that will do the inserting or appending\n\t * @param { Tag } target - only if inserting, insert before this tag's first child\n\t */\n\tfunction makeVirtual(src, target) {\n\t  var this$1 = this;\n\t\n\t  var head = createDOMPlaceholder(),\n\t    tail = createDOMPlaceholder(),\n\t    frag = createFrag(),\n\t    sib, el;\n\t\n\t  this.root.insertBefore(head, this.root.firstChild);\n\t  this.root.appendChild(tail);\n\t\n\t  this.__.head = el = head;\n\t  this.__.tail = tail;\n\t\n\t  while (el) {\n\t    sib = el.nextSibling;\n\t    frag.appendChild(el);\n\t    this$1.__.virts.push(el); // hold for unmounting\n\t    el = sib;\n\t  }\n\t\n\t  if (target)\n\t    { src.insertBefore(frag, target.__.head); }\n\t  else\n\t    { src.appendChild(frag); }\n\t}\n\t\n\t/**\n\t * Move virtual tag and all child nodes\n\t * @this Tag\n\t * @param { Node } src  - the node that will do the inserting\n\t * @param { Tag } target - insert before this tag's first child\n\t */\n\tfunction moveVirtual(src, target) {\n\t  var this$1 = this;\n\t\n\t  var el = this.__.head,\n\t    frag = createFrag(),\n\t    sib;\n\t\n\t  while (el) {\n\t    sib = el.nextSibling;\n\t    frag.appendChild(el);\n\t    el = sib;\n\t    if (el === this$1.__.tail) {\n\t      frag.appendChild(el);\n\t      src.insertBefore(frag, target.__.head);\n\t      break\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Get selectors for tags\n\t * @param   { Array } tags - tag names to select\n\t * @returns { String } selector\n\t */\n\tfunction selectTags(tags) {\n\t  // select all tags\n\t  if (!tags) {\n\t    var keys = Object.keys(__TAG_IMPL);\n\t    return keys + selectTags(keys)\n\t  }\n\t\n\t  return tags\n\t    .filter(function (t) { return !/[^-\\w]/.test(t); })\n\t    .reduce(function (list, t) {\n\t      var name = t.trim().toLowerCase();\n\t      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n\t    }, '')\n\t}\n\t\n\t\n\tvar tags = Object.freeze({\n\t\tgetTag: getTag,\n\t\tinheritFrom: inheritFrom,\n\t\tmoveChildTag: moveChildTag,\n\t\tinitChildTag: initChildTag,\n\t\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\t\tunmountAll: unmountAll,\n\t\tgetTagName: getTagName,\n\t\tcleanUpData: cleanUpData,\n\t\tarrayishAdd: arrayishAdd,\n\t\tarrayishRemove: arrayishRemove,\n\t\tmountTo: mountTo,\n\t\tmakeReplaceVirtual: makeReplaceVirtual,\n\t\tmakeVirtual: makeVirtual,\n\t\tmoveVirtual: moveVirtual,\n\t\tselectTags: selectTags\n\t});\n\t\n\t/**\n\t * Riot public api\n\t */\n\tvar settings = settings$1;\n\tvar util = {\n\t  tmpl: tmpl,\n\t  brackets: brackets,\n\t  styleManager: styleManager,\n\t  vdom: __TAGS_CACHE,\n\t  styleNode: styleManager.styleNode,\n\t  // export the riot internal utils as well\n\t  dom: dom,\n\t  check: check,\n\t  misc: misc,\n\t  tags: tags\n\t};\n\t\n\t// export the core props/methods\n\tvar Tag$$1 = Tag$2;\n\tvar tag$$1 = tag$1;\n\tvar tag2$$1 = tag2$1;\n\tvar mount$$1 = mount$1;\n\tvar mixin$$1 = mixin$1;\n\tvar update$$1 = update$1;\n\tvar unregister$$1 = unregister$1;\n\tvar version$$1 = version$1;\n\tvar observable = observable$1;\n\t\n\tvar riot$1 = extend({}, core, {\n\t  observable: observable$1,\n\t  settings: settings,\n\t  util: util,\n\t});\n\t\n\texports.settings = settings;\n\texports.util = util;\n\texports.Tag = Tag$$1;\n\texports.tag = tag$$1;\n\texports.tag2 = tag2$$1;\n\texports.mount = mount$$1;\n\texports.mixin = mixin$$1;\n\texports.update = update$$1;\n\texports.unregister = unregister$$1;\n\texports.version = version$$1;\n\texports.observable = observable;\n\texports['default'] = riot$1;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ }),\n/* 2 */\n/*!***********************************!*\\\n  !*** ./src/components/header.tag ***!\n  \\***********************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('header', '<button each=\"{navItems}\" onclick=\"{parent.route}\" type=\"button\" class=\"{parent.currentView === this.view ? \\'active btn btn-space btn-outline-primary\\' : \\'btn btn-space btn-outline-primary\\'}\">{this.title}</button>', '', '', function (opts) {\n\t\n\t  this.currentView = riot.routeState.view;\n\t\n\t  this.navItems = [{ title: 'Home', view: 'home' }, { title: 'Projects', view: 'projects' }];\n\t\n\t  this.route = function (evt) {\n\t    riot.route(evt.item.view);\n\t  };\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ }),\n/* 3 */\n/*!*************************************!*\\\n  !*** ./src/components/itemlist.tag ***!\n  \\*************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('itemlist', '<div class=\"row\"> <div class=\"col-md-6\"> <h3>{opts.title}</h3> <ul> <li each=\"{items}\">{this.name}</li> </ul> </div> <div class=\"col-md-6\"> <h3>{opts.title}</h3> <ul> <li each=\"{items}\">{this.name}</li> </ul> </div> </div>', '', '', function (opts) {\n\t  var _this = this;\n\t\n\t  this.items = [];\n\t\n\t  this.on('mount', function () {\n\t    riot.control.trigger(riot.EVT.loadItems);\n\t  });\n\t\n\t  riot.control.on(riot.EVT.loadItemsSuccess, function (items) {\n\t    _this.items = items;\n\t    _this.update();\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ }),\n/* 4 */\n/*!****************************!*\\\n  !*** ./src/pages/home.tag ***!\n  \\****************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\t__webpack_require__(/*! ../components/header.tag */ 2);\n\t\n\t__webpack_require__(/*! ../components/itemlist.tag */ 3);\n\t\n\triot.tag2('home', '<header></header> <div class=\"container\"> <itemlist title=\"Item List ABC\"></itemlist> </div>', '', '', function (opts) {});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ }),\n/* 5 */\n/*!********************************!*\\\n  !*** ./src/pages/projects.tag ***!\n  \\********************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\t__webpack_require__(/*! ../components/header.tag */ 2);\n\t\n\t__webpack_require__(/*! ../components/itemlist.tag */ 3);\n\t\n\triot.tag2('projects', '<header></header> <div class=\"container\"> <h2>Projects</h2> <p> Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aspernatur quia soluta optio excepturi, earum saepe explicabo veritatis fuga nesciunt, reprehenderit harum. Libero consequuntur neque fuga eos, aliquam id beatae eaque? </p> </div>', '', '', function (opts) {});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ }),\n/* 6 */\n/*!*****************************!*\\\n  !*** ./src/event-helper.js ***!\n  \\*****************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar _riotcontrol = __webpack_require__(/*! riotcontrol */ 14);\n\t\n\tvar _riotcontrol2 = _interopRequireDefault(_riotcontrol);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\triot.control = _riotcontrol2.default;\n\t\n\t// event names\n\t\n\triot.EVT = {\n\t  loadItems: 'load_items',\n\t  loadItemsSuccess: 'load_items_success'\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ }),\n/* 7 */\n/*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(/*! ./css/index.css */ 16);\n\t\n\t__webpack_require__(/*! ./event-helper */ 6);\n\t\n\t__webpack_require__(/*! ./stores/itemstore */ 9);\n\t\n\t__webpack_require__(/*! ./router.js */ 8);\n\n/***/ }),\n/* 8 */\n/*!***********************!*\\\n  !*** ./src/router.js ***!\n  \\***********************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _riotRoute = __webpack_require__(/*! riot-route */ 13);\n\t\n\tvar _riotRoute2 = _interopRequireDefault(_riotRoute);\n\t\n\t__webpack_require__(/*! ./pages/home.tag */ 4);\n\t\n\t__webpack_require__(/*! ./pages/projects.tag */ 5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// we need this to easily check the current route from every component\n\triot.route = _riotRoute2.default;\n\triot.routeState = {\n\t  view: ''\n\t};\n\t\n\tvar Router = function () {\n\t  function Router() {\n\t    _classCallCheck(this, Router);\n\t\n\t    this._currentView = null;\n\t    this._views = ['home', 'projects'];\n\t    this._defaultView = 'home';\n\t\n\t    riot.route(this._handleRoute.bind(this));\n\t    riot.route.exec(this._handleRoute.bind(this));\n\t  }\n\t\n\t  _createClass(Router, [{\n\t    key: '_handleRoute',\n\t    value: function _handleRoute(view) {\n\t\n\t      // load default view, if view is not in views list\n\t      if (this._views.indexOf(view) === -1) {\n\t        return riot.route(this._defaultView);\n\t      }\n\t\n\t      this._loadView(view);\n\t    }\n\t  }, {\n\t    key: '_loadView',\n\t    value: function _loadView(view) {\n\t      if (this._currentView) {\n\t        this._currentView.unmount(true);\n\t      }\n\t\n\t      riot.routeState.view = view;\n\t      this._currentView = riot.mount('#riot-app', view)[0];\n\t    }\n\t  }]);\n\t\n\t  return Router;\n\t}();\n\t\n\texports.default = new Router();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ }),\n/* 9 */\n/*!*********************************!*\\\n  !*** ./src/stores/itemstore.js ***!\n  \\*********************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ItemStore = function () {\n\t  function ItemStore() {\n\t    _classCallCheck(this, ItemStore);\n\t\n\t    riot.observable(this);\n\t    this.items = [];\n\t\n\t    this.bindEvents();\n\t  }\n\t\n\t  _createClass(ItemStore, [{\n\t    key: 'bindEvents',\n\t    value: function bindEvents() {\n\t      var _this = this;\n\t\n\t      this.on(riot.EVT.loadItems, function () {\n\t\n\t        // fake async op \n\t        setTimeout(function () {\n\t          _this.items = [{ name: 'test a' }, { name: 'test b' }, { name: 'test c' }, { name: 'test d' }];\n\t          _this.trigger(riot.EVT.loadItemsSuccess, _this.items);\n\t        }, 200);\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return ItemStore;\n\t}();\n\t\n\t// add store to riot control\n\t\n\t\n\tvar itemStore = new ItemStore();\n\triot.control.addStore(itemStore);\n\t\n\texports.default = itemStore;\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ }),\n/* 10 */\n/*!*************************************************************!*\\\n  !*** ./~/css-loader!./~/postcss-loader!./src/css/index.css ***!\n  \\*************************************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(/*! ../../~/css-loader/lib/css-base.js */ 11)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".btn-space{margin-right:5px}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }),\n/* 11 */\n/*!**************************************!*\\\n  !*** ./~/css-loader/lib/css-base.js ***!\n  \\**************************************/\n/***/ (function(module, exports) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\t// css base code, injected by the css-loader\n\tmodule.exports = function() {\n\t\tvar list = [];\n\t\n\t\t// return the list of modules as css string\n\t\tlist.toString = function toString() {\n\t\t\tvar result = [];\n\t\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\t\tvar item = this[i];\n\t\t\t\tif(item[2]) {\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(item[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.join(\"\");\n\t\t};\n\t\n\t\t// import a list of modules into the list\n\t\tlist.i = function(modules, mediaQuery) {\n\t\t\tif(typeof modules === \"string\")\n\t\t\t\tmodules = [[null, modules, \"\"]];\n\t\t\tvar alreadyImportedModules = {};\n\t\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\t\tvar id = this[i][0];\n\t\t\t\tif(typeof id === \"number\")\n\t\t\t\t\talreadyImportedModules[id] = true;\n\t\t\t}\n\t\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\t\tvar item = modules[i];\n\t\t\t\t// skip already imported module\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tlist.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn list;\n\t};\n\n\n/***/ }),\n/* 12 */\n/*!**********************************************!*\\\n  !*** ./~/riot-observable/dist/observable.js ***!\n  \\**********************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t;(function(window, undefined) {var observable = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {}\n\t\n\t  /**\n\t   * Private variables\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice\n\t\n\t  /**\n\t   * Public Api\n\t   */\n\t\n\t  // extend the el object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given `event` ands\n\t     * execute the `callback` each time an event is triggered.\n\t     * @param  { String } event - event id\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(event, fn) {\n\t        if (typeof fn == 'function')\n\t          (callbacks[event] = callbacks[event] || []).push(fn)\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given `event` listeners\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(event, fn) {\n\t        if (event == '*' && !fn) callbacks = {}\n\t        else {\n\t          if (fn) {\n\t            var arr = callbacks[event]\n\t            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t              if (cb == fn) arr.splice(i--, 1)\n\t            }\n\t          } else delete callbacks[event]\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given `event` and\n\t     * execute the `callback` at most once\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(event, fn) {\n\t        function on() {\n\t          el.off(event, on)\n\t          fn.apply(el, arguments)\n\t        }\n\t        return el.on(event, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to\n\t     * the given `event`\n\t     * @param   { String } event - event id\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(event) {\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns,\n\t          fn,\n\t          i\n\t\n\t        for (i = 0; i < arglen; i++) {\n\t          args[i] = arguments[i + 1] // skip first argument\n\t        }\n\t\n\t        fns = slice.call(callbacks[event] || [], 0)\n\t\n\t        for (i = 0; fn = fns[i]; ++i) {\n\t          fn.apply(el, args)\n\t        }\n\t\n\t        if (callbacks['*'] && event != '*')\n\t          el.trigger.apply(el, ['*', event].concat(args))\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  })\n\t\n\t  return el\n\t\n\t}\n\t  /* istanbul ignore next */\n\t  // support CommonJS, AMD & browser\n\t  if (true)\n\t    module.exports = observable\n\t  else if (typeof define === 'function' && define.amd)\n\t    define(function() { return observable })\n\t  else\n\t    window.observable = observable\n\t\n\t})(typeof window != 'undefined' ? window : undefined);\n\n/***/ }),\n/* 13 */\n/*!*******************************!*\\\n  !*** ./~/riot-route/index.js ***!\n  \\*******************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar observable = _interopDefault(__webpack_require__(/*! riot-observable */ 12));\n\t\n\t/**\n\t * Simple client-side router\n\t * @module riot-route\n\t */\n\t\n\tvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/;\n\tvar EVENT_LISTENER = 'EventListener';\n\tvar REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER;\n\tvar ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER;\n\tvar HAS_ATTRIBUTE = 'hasAttribute';\n\tvar POPSTATE = 'popstate';\n\tvar HASHCHANGE = 'hashchange';\n\tvar TRIGGER = 'trigger';\n\tvar MAX_EMIT_STACK_LEVEL = 3;\n\tvar win = typeof window != 'undefined' && window;\n\tvar doc = typeof document != 'undefined' && document;\n\tvar hist = win && history;\n\tvar loc = win && (hist.location || win.location);\n\tvar prot = Router.prototype;\n\tvar clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click';\n\tvar central = observable();\n\t\n\tvar started = false;\n\tvar routeFound = false;\n\tvar debouncedEmit;\n\tvar base;\n\tvar current;\n\tvar parser;\n\tvar secondParser;\n\tvar emitStack = [];\n\tvar emitStackLevel = 0;\n\t\n\t/**\n\t * Default parser. You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_PARSER(path) {\n\t  return path.split(/[/?#]/)\n\t}\n\t\n\t/**\n\t * Default parser (second). You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @param {string} filter - filter string (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_SECOND_PARSER(path, filter) {\n\t  var f = filter\n\t    .replace(/\\?/g, '\\\\?')\n\t    .replace(/\\*/g, '([^/?#]+?)')\n\t    .replace(/\\.\\./, '.*');\n\t  var re = new RegExp((\"^\" + f + \"$\"));\n\t  var args = path.match(re);\n\t\n\t  if (args) { return args.slice(1) }\n\t}\n\t\n\t/**\n\t * Simple/cheap debounce implementation\n\t * @param   {function} fn - callback\n\t * @param   {number} delay - delay in seconds\n\t * @returns {function} debounced function\n\t */\n\tfunction debounce(fn, delay) {\n\t  var t;\n\t  return function () {\n\t    clearTimeout(t);\n\t    t = setTimeout(fn, delay);\n\t  }\n\t}\n\t\n\t/**\n\t * Set the window listeners to trigger the routes\n\t * @param {boolean} autoExec - see route.start\n\t */\n\tfunction start(autoExec) {\n\t  debouncedEmit = debounce(emit, 1);\n\t  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit);\n\t  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n\t  doc[ADD_EVENT_LISTENER](clickEvent, click);\n\t  if (autoExec) { emit(true); }\n\t}\n\t\n\t/**\n\t * Router class\n\t */\n\tfunction Router() {\n\t  this.$ = [];\n\t  observable(this); // make it observable\n\t  central.on('stop', this.s.bind(this));\n\t  central.on('emit', this.e.bind(this));\n\t}\n\t\n\tfunction normalize(path) {\n\t  return path.replace(/^\\/|\\/$/, '')\n\t}\n\t\n\tfunction isString(str) {\n\t  return typeof str == 'string'\n\t}\n\t\n\t/**\n\t * Get the part after domain name\n\t * @param {string} href - fullpath\n\t * @returns {string} path from root\n\t */\n\tfunction getPathFromRoot(href) {\n\t  return (href || loc.href).replace(RE_ORIGIN, '')\n\t}\n\t\n\t/**\n\t * Get the part after base\n\t * @param {string} href - fullpath\n\t * @returns {string} path from base\n\t */\n\tfunction getPathFromBase(href) {\n\t  return base[0] === '#'\n\t    ? (href || loc.href || '').split(base)[1] || ''\n\t    : (loc ? getPathFromRoot(href) : href || '').replace(base, '')\n\t}\n\t\n\tfunction emit(force) {\n\t  // the stack is needed for redirections\n\t  var isRoot = emitStackLevel === 0;\n\t  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) { return }\n\t\n\t  emitStackLevel++;\n\t  emitStack.push(function() {\n\t    var path = getPathFromBase();\n\t    if (force || path !== current) {\n\t      central[TRIGGER]('emit', path);\n\t      current = path;\n\t    }\n\t  });\n\t  if (isRoot) {\n\t    var first;\n\t    while (first = emitStack.shift()) { first(); } // stack increses within this call\n\t    emitStackLevel = 0;\n\t  }\n\t}\n\t\n\tfunction click(e) {\n\t  if (\n\t    e.which !== 1 // not left click\n\t    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n\t    || e.defaultPrevented // or default prevented\n\t  ) { return }\n\t\n\t  var el = e.target;\n\t  while (el && el.nodeName !== 'A') { el = el.parentNode; }\n\t\n\t  if (\n\t    !el || el.nodeName !== 'A' // not A tag\n\t    || el[HAS_ATTRIBUTE]('download') // has download attr\n\t    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n\t    || el.target && el.target !== '_self' // another window or frame\n\t    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) === -1 // cross origin\n\t  ) { return }\n\t\n\t  if (el.href !== loc.href\n\t    && (\n\t      el.href.split('#')[0] === loc.href.split('#')[0] // internal jump\n\t      || base[0] !== '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n\t      || base[0] === '#' && el.href.split(base)[0] !== loc.href.split(base)[0] // outside of #base\n\t      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n\t    )) { return }\n\t\n\t  e.preventDefault();\n\t}\n\t\n\t/**\n\t * Go to the path\n\t * @param {string} path - destination path\n\t * @param {string} title - page title\n\t * @param {boolean} shouldReplace - use replaceState or pushState\n\t * @returns {boolean} - route not found flag\n\t */\n\tfunction go(path, title, shouldReplace) {\n\t  // Server-side usage: directly execute handlers for the path\n\t  if (!hist) { return central[TRIGGER]('emit', getPathFromBase(path)) }\n\t\n\t  path = base + normalize(path);\n\t  title = title || doc.title;\n\t  // browsers ignores the second parameter `title`\n\t  shouldReplace\n\t    ? hist.replaceState(null, title, path)\n\t    : hist.pushState(null, title, path);\n\t  // so we need to set it manually\n\t  doc.title = title;\n\t  routeFound = false;\n\t  emit();\n\t  return routeFound\n\t}\n\t\n\t/**\n\t * Go to path or set action\n\t * a single string:                go there\n\t * two strings:                    go there with setting a title\n\t * two strings and boolean:        replace history with setting a title\n\t * a single function:              set an action on the default route\n\t * a string/RegExp and a function: set an action on the route\n\t * @param {(string|function)} first - path / action / filter\n\t * @param {(string|RegExp|function)} second - title / action\n\t * @param {boolean} third - replace flag\n\t */\n\tprot.m = function(first, second, third) {\n\t  if (isString(first) && (!second || isString(second))) { go(first, second, third || false); }\n\t  else if (second) { this.r(first, second); }\n\t  else { this.r('@', first); }\n\t};\n\t\n\t/**\n\t * Stop routing\n\t */\n\tprot.s = function() {\n\t  this.off('*');\n\t  this.$ = [];\n\t};\n\t\n\t/**\n\t * Emit\n\t * @param {string} path - path\n\t */\n\tprot.e = function(path) {\n\t  this.$.concat('@').some(function(filter) {\n\t    var args = (filter === '@' ? parser : secondParser)(normalize(path), normalize(filter));\n\t    if (typeof args != 'undefined') {\n\t      this[TRIGGER].apply(null, [filter].concat(args));\n\t      return routeFound = true // exit from loop\n\t    }\n\t  }, this);\n\t};\n\t\n\t/**\n\t * Register route\n\t * @param {string} filter - filter for matching to url\n\t * @param {function} action - action to register\n\t */\n\tprot.r = function(filter, action) {\n\t  if (filter !== '@') {\n\t    filter = '/' + normalize(filter);\n\t    this.$.push(filter);\n\t  }\n\t  this.on(filter, action);\n\t};\n\t\n\tvar mainRouter = new Router();\n\tvar route = mainRouter.m.bind(mainRouter);\n\t\n\t/**\n\t * Create a sub router\n\t * @returns {function} the method of a new Router object\n\t */\n\troute.create = function() {\n\t  var newSubRouter = new Router();\n\t  // assign sub-router's main method\n\t  var router = newSubRouter.m.bind(newSubRouter);\n\t  // stop only this sub-router\n\t  router.stop = newSubRouter.s.bind(newSubRouter);\n\t  return router\n\t};\n\t\n\t/**\n\t * Set the base of url\n\t * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n\t */\n\troute.base = function(arg) {\n\t  base = arg || '#';\n\t  current = getPathFromBase(); // recalculate current path\n\t};\n\t\n\t/** Exec routing right now **/\n\troute.exec = function() {\n\t  emit(true);\n\t};\n\t\n\t/**\n\t * Replace the default router to yours\n\t * @param {function} fn - your parser function\n\t * @param {function} fn2 - your secondParser function\n\t */\n\troute.parser = function(fn, fn2) {\n\t  if (!fn && !fn2) {\n\t    // reset parser for testing...\n\t    parser = DEFAULT_PARSER;\n\t    secondParser = DEFAULT_SECOND_PARSER;\n\t  }\n\t  if (fn) { parser = fn; }\n\t  if (fn2) { secondParser = fn2; }\n\t};\n\t\n\t/**\n\t * Helper function to get url query as an object\n\t * @returns {object} parsed query\n\t */\n\troute.query = function() {\n\t  var q = {};\n\t  var href = loc.href || current;\n\t  href.replace(/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v; });\n\t  return q\n\t};\n\t\n\t/** Stop routing **/\n\troute.stop = function () {\n\t  if (started) {\n\t    if (win) {\n\t      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit);\n\t      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n\t      doc[REMOVE_EVENT_LISTENER](clickEvent, click);\n\t    }\n\t    central[TRIGGER]('stop');\n\t    started = false;\n\t  }\n\t};\n\t\n\t/**\n\t * Start routing\n\t * @param {boolean} autoExec - automatically exec after starting if true\n\t */\n\troute.start = function (autoExec) {\n\t  if (!started) {\n\t    if (win) {\n\t      if (document.readyState === 'interactive' || document.readyState === 'complete') {\n\t        start(autoExec);\n\t      }\n\t      else {\n\t        document.onreadystatechange = function () {\n\t          if (document.readyState === 'interactive') {\n\t            // the timeout is needed to solve\n\t            // a weird safari bug https://github.com/riot/route/issues/33\n\t            setTimeout(function() { start(autoExec); }, 1);\n\t          }\n\t        };\n\t      }\n\t    }\n\t    started = true;\n\t  }\n\t};\n\t\n\t/** Prepare the router **/\n\troute.base();\n\troute.parser();\n\t\n\tmodule.exports = route;\n\n\n/***/ }),\n/* 14 */\n/*!**************************************!*\\\n  !*** ./~/riotcontrol/riotcontrol.js ***!\n  \\**************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar RiotControl = {\r\n\t  _stores: [],\r\n\t  addStore: function(store) {\r\n\t    this._stores.push(store);\r\n\t  },\r\n\t  reset: function() {\r\n\t    this._stores = [];\r\n\t  }\r\n\t};\r\n\t\r\n\t['on','one','off','trigger'].forEach(function(api){\r\n\t  RiotControl[api] = function() {\r\n\t    var args = [].slice.call(arguments);\r\n\t    this._stores.forEach(function(el){\r\n\t      el[api].apply(el, args);\r\n\t    });\r\n\t  };\r\n\t});\r\n\t\r\n\tif (true) module.exports = RiotControl;\r\n\n\n/***/ }),\n/* 15 */\n/*!*************************************!*\\\n  !*** ./~/style-loader/addStyles.js ***!\n  \\*************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\tvar stylesInDom = {},\n\t\tmemoize = function(fn) {\n\t\t\tvar memo;\n\t\t\treturn function () {\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\t\treturn memo;\n\t\t\t};\n\t\t},\n\t\tisOldIE = memoize(function() {\n\t\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t\t}),\n\t\tgetHeadElement = memoize(function () {\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t\t}),\n\t\tsingletonElement = null,\n\t\tsingletonCounter = 0,\n\t\tstyleElementsInsertedAtTop = [];\n\t\n\tmodule.exports = function(list, options) {\n\t\tif(true) {\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t\t}\n\t\n\t\toptions = options || {};\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t\t// tags it will allow on a page\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\t\n\t\t// By default, add <style> tags to the bottom of <head>.\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\t\n\t\tvar styles = listToStyles(list);\n\t\taddStylesToDom(styles, options);\n\t\n\t\treturn function update(newList) {\n\t\t\tvar mayRemove = [];\n\t\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\t\tvar item = styles[i];\n\t\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\t\tdomStyle.refs--;\n\t\t\t\tmayRemove.push(domStyle);\n\t\t\t}\n\t\t\tif(newList) {\n\t\t\t\tvar newStyles = listToStyles(newList);\n\t\t\t\taddStylesToDom(newStyles, options);\n\t\t\t}\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\t\tvar domStyle = mayRemove[i];\n\t\t\t\tif(domStyle.refs === 0) {\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction addStylesToDom(styles, options) {\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tif(domStyle) {\n\t\t\t\tdomStyle.refs++;\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t\t}\n\t\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar parts = [];\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction listToStyles(list) {\n\t\tvar styles = [];\n\t\tvar newStyles = {};\n\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i];\n\t\t\tvar id = item[0];\n\t\t\tvar css = item[1];\n\t\t\tvar media = item[2];\n\t\t\tvar sourceMap = item[3];\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\t\tif(!newStyles[id])\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\t\telse\n\t\t\t\tnewStyles[id].parts.push(part);\n\t\t}\n\t\treturn styles;\n\t}\n\t\n\tfunction insertStyleElement(options, styleElement) {\n\t\tvar head = getHeadElement();\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\t\tif (options.insertAt === \"top\") {\n\t\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t\t} else {\n\t\t\t\thead.appendChild(styleElement);\n\t\t\t}\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t\t} else if (options.insertAt === \"bottom\") {\n\t\t\thead.appendChild(styleElement);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t\t}\n\t}\n\t\n\tfunction removeStyleElement(styleElement) {\n\t\tstyleElement.parentNode.removeChild(styleElement);\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\t\tif(idx >= 0) {\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t\t}\n\t}\n\t\n\tfunction createStyleElement(options) {\n\t\tvar styleElement = document.createElement(\"style\");\n\t\tstyleElement.type = \"text/css\";\n\t\tinsertStyleElement(options, styleElement);\n\t\treturn styleElement;\n\t}\n\t\n\tfunction createLinkElement(options) {\n\t\tvar linkElement = document.createElement(\"link\");\n\t\tlinkElement.rel = \"stylesheet\";\n\t\tinsertStyleElement(options, linkElement);\n\t\treturn linkElement;\n\t}\n\t\n\tfunction addStyle(obj, options) {\n\t\tvar styleElement, update, remove;\n\t\n\t\tif (options.singleton) {\n\t\t\tvar styleIndex = singletonCounter++;\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t\t} else if(obj.sourceMap &&\n\t\t\ttypeof URL === \"function\" &&\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\t\ttypeof Blob === \"function\" &&\n\t\t\ttypeof btoa === \"function\") {\n\t\t\tstyleElement = createLinkElement(options);\n\t\t\tupdate = updateLink.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t\tif(styleElement.href)\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t\t};\n\t\t} else {\n\t\t\tstyleElement = createStyleElement(options);\n\t\t\tupdate = applyToTag.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t};\n\t\t}\n\t\n\t\tupdate(obj);\n\t\n\t\treturn function updateStyle(newObj) {\n\t\t\tif(newObj) {\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\t\treturn;\n\t\t\t\tupdate(obj = newObj);\n\t\t\t} else {\n\t\t\t\tremove();\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar replaceText = (function () {\n\t\tvar textStore = [];\n\t\n\t\treturn function (index, replacement) {\n\t\t\ttextStore[index] = replacement;\n\t\t\treturn textStore.filter(Boolean).join('\\n');\n\t\t};\n\t})();\n\t\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\t\tvar css = remove ? \"\" : obj.css;\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t\t} else {\n\t\t\tvar cssNode = document.createTextNode(css);\n\t\t\tvar childNodes = styleElement.childNodes;\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\t\tif (childNodes.length) {\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t\t} else {\n\t\t\t\tstyleElement.appendChild(cssNode);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction applyToTag(styleElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar media = obj.media;\n\t\n\t\tif(media) {\n\t\t\tstyleElement.setAttribute(\"media\", media)\n\t\t}\n\t\n\t\tif(styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = css;\n\t\t} else {\n\t\t\twhile(styleElement.firstChild) {\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t\t}\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\n\t\t}\n\t}\n\t\n\tfunction updateLink(linkElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar sourceMap = obj.sourceMap;\n\t\n\t\tif(sourceMap) {\n\t\t\t// http://stackoverflow.com/a/26603875\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t\t}\n\t\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\n\t\n\t\tvar oldSrc = linkElement.href;\n\t\n\t\tlinkElement.href = URL.createObjectURL(blob);\n\t\n\t\tif(oldSrc)\n\t\t\tURL.revokeObjectURL(oldSrc);\n\t}\n\n\n/***/ }),\n/* 16 */\n/*!***************************!*\\\n  !*** ./src/css/index.css ***!\n  \\***************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(/*! !../../~/css-loader!../../~/postcss-loader!./index.css */ 10);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(/*! ../../~/style-loader/addStyles.js */ 15)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!../../node_modules/postcss-loader/index.js!./index.css\", function() {\n\t\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/postcss-loader/index.js!./index.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d95d52134290c7e4b5a6","/* Riot v3.4.3, @license MIT */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.riot = global.riot || {})));\n}(this, (function (exports) { 'use strict';\n\nvar __TAGS_CACHE = [];\nvar __TAG_IMPL = {};\nvar GLOBAL_MIXIN = '__global_mixin';\nvar ATTRS_PREFIX = 'riot-';\nvar REF_DIRECTIVES = ['ref', 'data-ref'];\nvar IS_DIRECTIVE = 'data-is';\nvar CONDITIONAL_DIRECTIVE = 'if';\nvar LOOP_DIRECTIVE = 'each';\nvar LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';\nvar SHOW_DIRECTIVE = 'show';\nvar HIDE_DIRECTIVE = 'hide';\nvar RIOT_EVENTS_KEY = '__riot-events__';\nvar T_STRING = 'string';\nvar T_OBJECT = 'object';\nvar T_UNDEF  = 'undefined';\nvar T_FUNCTION = 'function';\nvar XLINK_NS = 'http://www.w3.org/1999/xlink';\nvar XLINK_REGEX = /^xlink:(\\w+)/;\nvar WIN = typeof window === T_UNDEF ? undefined : window;\nvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\nvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\nvar RE_EVENTS_PREFIX = /^on/;\nvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\nvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\nvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\nvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\nvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n/**\n * Check Check if the passed argument is undefined\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isUndefined(value) || value === null || value === ''\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } -\n */\nfunction isWritable(obj, key) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n/**\n * Check if passed argument is a reserved name\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isReservedName(value) {\n  return RE_RESERVED_NAMES.test(value)\n}\n\nvar check = Object.freeze({\n\tisBoolAttr: isBoolAttr,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisUndefined: isUndefined,\n\tisString: isString,\n\tisBlank: isBlank,\n\tisArray: isArray,\n\tisWritable: isWritable,\n\tisReservedName: isReservedName\n});\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFrag() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n */\n/* istanbul ignore next */\nfunction setInnerHTML(container, html) {\n  if (!isUndefined(container.innerHTML))\n    { container.innerHTML = html; }\n    // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml');\n    var node = container.ownerDocument.importNode(doc.documentElement, true);\n    container.appendChild(node);\n  }\n}\n\n/**\n * Toggle the visibility of any DOM node\n * @param   { Object }  dom - DOM node we want to hide\n * @param   { Boolean } show - do we want to show it?\n */\n\nfunction toggleVisibility(dom, show) {\n  dom.style.display = show ? '' : 'none';\n  dom['hidden'] = show ? false : true;\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Convert a style object to a string\n * @param   { Object } style - style object we need to parse\n * @returns { String } resulting css string\n * @example\n * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n */\nfunction styleObjectToString(style) {\n  return Object.keys(style).reduce(function (acc, prop) {\n    return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n  }, '')\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttrs(html, fn) {\n  if (!html)\n    { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateFrag: createFrag,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tmkEl: mkEl,\n\tsetInnerHTML: setInnerHTML,\n\ttoggleVisibility: toggleVisibility,\n\tremAttr: remAttr,\n\tstyleObjectToString: styleObjectToString,\n\tgetAttr: getAttr,\n\tsetAttr: setAttr,\n\tsafeInsert: safeInsert,\n\twalkAttrs: walkAttrs,\n\twalkNodes: walkNodes\n});\n\nvar styleNode;\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\nvar needsInject = false;\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style');\n    setAttr(newNode, 'type', 'text/css');\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n    /* istanbul ignore next */\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    }\n    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\n    return newNode\n  })();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n    needsInject = true;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN || !needsInject) { return }\n    needsInject = false;\n    var style = Object.keys(byName)\n      .map(function(k) { return byName[k] })\n      .concat(remainder).join('\\n');\n    /* istanbul ignore next */\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n};\n\n/**\n * The riot template engine\n * @version v3.0.3\n */\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\n/* istanbul ignore next */\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n    },\n\n    DEFAULT = '{ }';\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(str, match[2], re.lastIndex);\n          continue\n        }\n        if (!match[3]) {\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    return parts\n\n    function unescapeStr (s) {\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function skipBraces (s, ch, ix) {\n      var\n        match,\n        recch = FINDBRACES[ch];\n\n      recch.lastIndex = ix;\n      ix = 1;\n      while ((match = recch.exec(s))) {\n        if (match[1] &&\n          !(match[1] === ch ? ++ix : --ix)) { break }\n      }\n      return ix ? s.length : recch.lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\n/* istanbul ignore next */\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.__ && ctx.__.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n    else if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      if (err.riotData.tagName) {\n        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName);\n      }\n      console.error(err);\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var\n    CH_IDEXPR = String.fromCharCode(0x2057),\n    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_DQUOTE = /\\u2057/g,\n    RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr[0]) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.3';\n\n  return _tmpl\n\n})();\n\n/* istanbul ignore next */\nvar observable$1 = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n  var i = 0;\n  for (; i < len; ++i) {\n    fn(list[i], i);\n  }\n  return list\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments;\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\nvar misc = Object.freeze({\n\teach: each,\n\tcontains: contains,\n\ttoCamel: toCamel,\n\tstartsWith: startsWith,\n\tdefineProperty: defineProperty,\n\textend: extend\n});\n\nvar settings$1 = extend(Object.create(brackets.settings), {\n  skipAnonymousTags: true\n});\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this.__.parent,\n    item = this.__.item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag.__.item;\n      ptag = ptag.__.parent;\n    } }\n\n  // override the event properties\n  /* istanbul ignore next */\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParentTag(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName,\n    cb = handleEvent.bind(tag, dom, handler);\n\n  // normalize event name\n  eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n  // cache the listener into the listeners array\n  if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n  if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n  if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n  dom[RIOT_EVENTS_KEY][name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag }    parent - parent for tag creation\n * @param { String } tagName - tag implementation we want to use\n */\nfunction updateDataIs(expr, parent, tagName) {\n  var conf, isVirtual, head, ref;\n\n  if (expr.tag && expr.tagName === tagName) {\n    expr.tag.update();\n    return\n  }\n\n  isVirtual = expr.dom.tagName === 'VIRTUAL';\n  // sync _parent to accommodate changing tagnames\n  if (expr.tag) {\n    // need placeholder before unmount\n    if(isVirtual) {\n      head = expr.tag.__.head;\n      ref = createDOMPlaceholder();\n      head.parentNode.insertBefore(ref, head);\n    }\n\n    expr.tag.unmount(true);\n  }\n\n  if (!isString(tagName)) { return }\n\n  expr.impl = __TAG_IMPL[tagName];\n  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n  each(expr.attrs, function (a) { return setAttr(expr.tag.root, a.name, a.value); });\n  expr.tagName = tagName;\n  expr.tag.mount();\n  if (isVirtual)\n    { makeReplaceVirtual(expr.tag, ref || expr.tag.root); } // root exist first time, after use placeholder\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.__.onUnmount = function() {\n    var delName = expr.tag.opts.dataIs,\n      tags = expr.tag.parent.tags,\n      _tags = expr.tag.__.parent.tags;\n    arrayishRemove(tags, delName, expr.tag);\n    arrayishRemove(_tags, delName, expr.tag);\n    expr.tag.unmount();\n  };\n}\n\n/**\n * Nomalize any attribute removing the \"riot-\" prefix\n * @param   { String } attrName - original attribute name\n * @returns { String } valid html attribute name\n */\nfunction normalizeAttrName(attrName) {\n  if (!attrName) { return null }\n  attrName = attrName.replace(ATTRS_PREFIX, '');\n  if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n  return attrName\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  if (this.root && getAttr(this.root,'virtualized')) { return }\n\n  var dom = expr.dom,\n    // remove the riot- prefix\n    attrName = normalizeAttrName(expr.attr),\n    isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),\n    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n    parent = dom && (expr.parent || dom.parentNode),\n    // detect the style attributes\n    isStyleAttr = attrName === 'style',\n    isClassAttr = attrName === 'class',\n    isObj,\n    value;\n\n  // if it's a tag we could totally skip the rest\n  if (expr._riot_id) {\n    if (expr.isMounted) {\n      expr.update();\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n      if (isVirtual) {\n        makeReplaceVirtual(expr, expr.root);\n      }\n    }\n    return\n  }\n  // if this expression has the update method it means it can handle the DOM changes by itself\n  if (expr.update) { return expr.update() }\n\n  // ...it seems to be a simple expression so we try to calculat its value\n  value = tmpl(expr.expr, isToggle ? extend(Object.create(this.parent), this) : this);\n  isObj = isObject(value);\n\n  // convert the style/class objects to strings\n  if (isObj) {\n    isObj = !isClassAttr && !isStyleAttr;\n    if (isClassAttr) {\n      value = tmpl(JSON.stringify(value), this);\n    } else if (isStyleAttr) {\n      value = styleObjectToString(value);\n    }\n  }\n\n  // remove original attribute\n  if (expr.attr && (!expr.isAttrRemoved || !value)) {\n    remAttr(dom, expr.attr);\n    expr.isAttrRemoved = true;\n  }\n\n  // for the boolean attributes we don't need the value\n  // we can convert it to checked=true to checked=checked\n  if (expr.bool) { value = value ? attrName : false; }\n  if (expr.isRtag) { return updateDataIs(expr, this, value) }\n  if (expr.wasParsedOnce && expr.value === value) { return }\n\n  // update the expression value\n  expr.value = value;\n  expr.wasParsedOnce = true;\n\n  // if the value is an object we can not do much more with it\n  if (isObj && !isToggle) { return }\n  // avoid to render undefined/null values\n  if (isBlank(value)) { value = ''; }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (isToggle) {\n    toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n  // handle attributes\n  } else {\n    if (expr.bool) {\n      dom[attrName] = value;\n    }\n\n    if (attrName === 'value' && dom.value !== value) {\n      dom.value = value;\n    }\n\n    if (!isBlank(value) && value !== false) {\n      setAttr(dom, attrName, value);\n    }\n\n    // make sure that in case of style changes\n    // the element stays hidden\n    if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction updateAllExpressions(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\nvar IfExpr = {\n  init: function init(dom, tag, expr) {\n    remAttr(dom, CONDITIONAL_DIRECTIVE);\n    this.tag = tag;\n    this.expr = expr;\n    this.stub = document.createTextNode('');\n    this.pristine = dom;\n\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update() {\n    this.value = tmpl(this.expr, this.tag);\n\n    if (this.value && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n      this.expressions = [];\n      parseExpressions.apply(this.tag, [this.current, this.expressions, true]);\n    } else if (!this.value && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode) {\n        this.current.parentNode.removeChild(this.current);\n      }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (this.value) { updateAllExpressions.call(this.tag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n    delete this.pristine;\n    delete this.parentNode;\n    delete this.stub;\n  }\n};\n\nvar RefExpr = {\n  init: function init(dom, parent, attrName, attrValue) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    return this\n  },\n  update: function update() {\n    var old = this.value;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.tag || this.dom;\n\n    this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n\n    if (isBlank(this.value)) {\n      // if the value is blank, we remove it\n      remAttr(this.dom, this.attr);\n    } else {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(\n        customParent.refs,\n        this.value,\n        tagOrDom,\n        // use an array if it's a looped node and the ref is not an expression\n        null,\n        this.parent.__.index\n      ); }\n      // set the actual DOM attr\n      setAttr(this.dom, this.attr, this.value);\n    }\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n    delete this.dom;\n    delete this.parent;\n  }\n};\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? Object.create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n  var i = tags.length,\n    j = items.length;\n\n  while (i > j) {\n    i--;\n    remove.apply(tags[i], [tags, i]);\n  }\n}\n\n\n/**\n * Remove a child tag\n * @this Tag\n * @param   { Array } tags - tags collection\n * @param   { Number } i - index of the tag to remove\n */\nfunction remove(tags, i) {\n  tags.splice(i, 1);\n  this.unmount();\n  arrayishRemove(this.parent, this, this.__.tagName, true);\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    moveChildTag.apply(this$1.tags[tagName], [tagName, i]);\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, LOOP_DIRECTIVE);\n\n  var mustReorder = typeof getAttr(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE),\n    tagName = getTagName(dom),\n    impl = __TAG_IMPL[tagName],\n    parentNode = dom.parentNode,\n    placeholder = createDOMPlaceholder(),\n    child = getTag(dom),\n    ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE),\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isLoop = true,\n    isAnonymous = !__TAG_IMPL[tagName],\n    isVirtual = dom.tagName === 'VIRTUAL';\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { remAttr(dom, CONDITIONAL_DIRECTIVE); }\n\n  // insert a marked where the loop tags will be injected\n  parentNode.insertBefore(placeholder, dom);\n  parentNode.removeChild(dom);\n\n  expr.update = function updateEach() {\n    // get the new items collection\n    expr.value = tmpl(expr.val, parent);\n\n    var frag = createFrag(),\n      items = expr.value,\n      isObject$$1 = !isArray(items) && !isString(items),\n      root = placeholder.parentNode;\n\n    // object loop. any changes cause full redraw\n    if (isObject$$1) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, items[key], key)\n        }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function(item, i) {\n        if (expr.key && !isObject$$1)\n          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\n        return !!tmpl(ifExpr, extend(Object.create(parent), item))\n      });\n    }\n\n    // loop all the new items\n    each(items, function(item, i) {\n      // reorder only if the items are objects\n      var\n        doReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        isNew = oldPos === -1,\n        pos = !isNew && doReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos],\n        mustAppend = i >= oldItems.length,\n        mustCreate =  doReorder && isNew || !doReorder && !tag;\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\n      // new tag\n      if (mustCreate) {\n        tag = new Tag$1(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          tagName: tagName,\n          root: dom.cloneNode(isAnonymous),\n          item: item,\n          index: i,\n        }, dom.innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n      } else if (pos !== i && doReorder) {\n        // move\n        if (contains(items, oldItems[pos])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n          // move the old tag instance\n          tags.splice(i, 0, tags.splice(pos, 1)[0]);\n          // move the old item\n          oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        }\n\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag.__.item = item;\n      tag.__.index = i;\n      tag.__.parent = parent;\n\n      if (!mustCreate) { tag.update(item); }\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags);\n\n    // clone the items array\n    oldItems = items.slice();\n\n    root.insertBefore(frag, placeholder);\n  };\n\n  expr.unmount = function() {\n    each(tags, function(t) { t.unmount(); });\n  };\n\n  return expr\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Array } expressions - empty array where the expressions will be added\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Object } an object containing the root noode and the dom tree\n */\nfunction parseExpressions(root, expressions, mustIncludeRoot) {\n  var this$1 = this;\n\n  var tree = {parent: {children: expressions}};\n\n  walkNodes(root, function (dom, ctx) {\n    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return ctx } // not an element\n\n    var isVirtual = dom.tagName === 'VIRTUAL';\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttr(dom, LOOP_DIRECTIVE)) {\n      if(isVirtual) { setAttr(dom, 'loopVirtual', true); } // ignore here, handled in _each\n      parent.children.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {\n      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n      return false\n    }\n\n    if (expr = getAttr(dom, IS_DIRECTIVE)) {\n      if (tmpl.hasExpr(expr)) {\n        parent.children.push({isRtag: true, expr: expr, dom: dom, attrs: [].slice.call(dom.attributes)});\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = getTag(dom);\n    if(isVirtual) {\n      if(getAttr(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n      if(!tagImpl && !getAttr(dom, 'virtualized') && !getAttr(dom, 'loopVirtual'))  // ok to create virtual tag\n        { tagImpl = { tmpl: dom.outerHTML }; }\n    }\n\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      if(isVirtual && !getAttr(dom, IS_DIRECTIVE)) { // handled in update\n        // can not remove attribute like directives\n        // so flag for removal after creation to prevent maximum stack error\n        setAttr(dom, 'virtualized', true);\n\n        var tag = new Tag$1({ tmpl: dom.outerHTML },\n          {root: dom, parent: this$1},\n          dom.innerHTML);\n        parent.children.push(tag); // no return, anonymous tag, keep parsing\n      } else {\n        var conf = {root: dom, parent: this$1, hasImpl: true};\n        parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n        return false\n      }\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n      if (!expr) { return }\n      parent.children.push(expr);\n    }]);\n\n    // whatever the parent is, all child elements get the same parent.\n    // If this element had an if-attr, that's the parent for all child elements\n    return {parent: parent}\n  }, tree);\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    var name = attr.name, bool = isBoolAttr(name), expr;\n\n    if (contains(REF_DIRECTIVES, name)) {\n      expr =  Object.create(RefExpr).init(dom, this$1, name, attr.value);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar reHasYield  = /<yield\\b/i;\nvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\nvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\nvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\nvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\nvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\nvar GENERIC = 'div';\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  /* istanbul ignore next */\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n    tagName = match && match[1].toLowerCase(),\n    el = mkEl(GENERIC);\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl); }\n\n  return el\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag$2(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag$1(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mountTo(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag$1(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2$1(name, tmpl, css, attrs, fn) {\n  if (css) { styleManager.add(css, name); }\n\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount$1(selector, tagName, opts) {\n  var tags = [];\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, IS_DIRECTIVE);\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttr(root, IS_DIRECTIVE, tagName);\n      }\n\n      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag)\n        { tags.push(tag); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  var elem;\n  var allTags;\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = selectTags() :\n      // or just the ones named like the selector\n      selector + selectTags(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectTags();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar mixins_id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin$1(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin$1((\"__unnamed_\" + (mixins_id++)), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error('Unregistered mixin: ' + name) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$1() {\n  return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n}\n\nfunction unregister$1(name) {\n  delete __TAG_IMPL[name];\n}\n\nvar version$1 = 'v3.4.3';\n\n\nvar core = Object.freeze({\n\tTag: Tag$2,\n\ttag: tag$1,\n\ttag2: tag2$1,\n\tmount: mount$1,\n\tmixin: mixin$1,\n\tupdate: update$1,\n\tunregister: unregister$1,\n\tversion: version$1\n});\n\n// counter to give a unique id to all the Tag instances\nvar __uid = 0;\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n\n  var ctx = !isAnonymous && isLoop ? this : parent || this;\n  each(instAttrs, function (attr) {\n    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n    // normalize the attribute names\n    opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n\n/**\n * Tag class\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction Tag$1(impl, conf, innerHTML) {\n  if ( impl === void 0 ) impl = {};\n  if ( conf === void 0 ) conf = {};\n\n  var opts = extend({}, conf.opts),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    isAnonymous = !!conf.isAnonymous,\n    skipAnonymous = settings$1.skipAnonymousTags && isAnonymous,\n    item = cleanUpData(conf.item),\n    index = conf.index, // available only for the looped nodes\n    instAttrs = [], // All attributes on the Tag when it's first parsed\n    implAttrs = [], // expressions on this type of Tag\n    expressions = [],\n    root = conf.root,\n    tagName = conf.tagName || getTagName(root),\n    isVirtual = tagName === 'virtual',\n    propsInSyncWithParent = [],\n    dom;\n\n  // make this tag observable\n  if (!skipAnonymous) { observable$1(this); }\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  this.isMounted = false;\n\n  defineProperty(this, '__', {\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    tagName: tagName,\n    index: index,\n    isLoop: isLoop,\n    // tags having event listeners\n    // it would be better to use weak maps here but we can not introduce breaking changes now\n    listeners: [],\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    tail: null,\n    head: null,\n    parent: null,\n    item: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n  defineProperty(this, 'root', root);\n  extend(this, { opts: opts }, item);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  defineProperty(this, 'parent', parent || null);\n  defineProperty(this, 'tags', {});\n  defineProperty(this, 'refs', {});\n\n  dom = isLoop && isAnonymous ? root : mkdom(impl.tmpl, innerHTML, isLoop);\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'update', function tagUpdate(data) {\n    var nextOpts = {},\n      canTrigger = this.isMounted && !skipAnonymous;\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data);\n    extend(this, data);\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, nextOpts, instAttrs]);\n\n    if (canTrigger && this.isMounted && isFunction(this.shouldUpdate) && !this.shouldUpdate(data, nextOpts)) {\n      return this\n    }\n\n    // inherit properties from the parent, but only for isAnonymous tags\n    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n    extend(opts, nextOpts);\n    if (canTrigger) { this.trigger('update', data); }\n    updateAllExpressions.call(this, expressions);\n    if (canTrigger) { this.trigger('updated'); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mixin', function tagMixin() {\n    var this$1 = this;\n\n    each(arguments, function (mix) {\n      var instance, obj;\n      var props = [];\n\n      // properties blacklisted and will not be bound to the tag instance\n      var propsBlacklist = ['init', '__proto__'];\n\n      mix = isString(mix) ? mixin$1(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to this\n        // allow mixins to override other properties/parent mixins\n        if (!contains(propsBlacklist, key)) {\n          // check for getters/setters\n          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(this$1, key, descriptor);\n          } else {\n            this$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(this$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(this$1)(); }\n    });\n    return this\n  }.bind(this));\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mount', function tagMount() {\n    var this$1 = this;\n\n    root._tag = this; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n      attr.expr = expr;\n      instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    implAttrs = [];\n    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttr(root, attr.name, attr.value); }\n    }]);\n\n    // initialiation\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin$1(GLOBAL_MIXIN);\n\n    if (globalMixin && !skipAnonymous) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          this$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (impl.fn) { impl.fn.call(this, opts); }\n\n    if (!skipAnonymous) { this.trigger('before-mount'); }\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions.apply(this, [dom, expressions, isAnonymous]);\n\n    this.update(item);\n\n    if (!isAnonymous) {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n    }\n\n    defineProperty(this, 'root', root);\n    defineProperty(this, 'isMounted', true);\n\n    if (skipAnonymous) { return }\n\n    // if it's not a child tag we can trigger its mount event\n    if (!this.parent) {\n      this.trigger('mount');\n    }\n    // otherwise we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n    else {\n      var p = getImmediateCustomParentTag(this.parent);\n      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n        this$1.trigger('mount');\n      });\n    }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n    var this$1 = this;\n\n    var el = this.root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __TAGS_CACHE.indexOf(this);\n\n    if (!skipAnonymous) { this.trigger('before-unmount'); }\n\n    // clear all attributes coming from the mounted tag\n    walkAttrs(impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX))\n        { name = name.slice(ATTRS_PREFIX.length); }\n      remAttr(root, name);\n    });\n\n    // remove all the event listeners\n    this.__.listeners.forEach(function (dom) {\n      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n      });\n    });\n\n    // remove this tag instance from the global virtualDom variable\n    if (tagIndex !== -1)\n      { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    if (p || isVirtual) {\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent);\n\n        if (isVirtual) {\n          Object.keys(this.tags).forEach(function (tagName) {\n            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n          });\n        } else {\n          arrayishRemove(ptag.tags, tagName, this);\n          if(parent !== ptag) // remove from _parent too\n            { arrayishRemove(parent.tags, tagName, this); }\n        }\n      } else {\n        // remove the tag contents\n        setInnerHTML(el, '');\n      }\n\n      if (p && !mustKeepRoot) { p.removeChild(el); }\n    }\n\n    if (this.__.virts) {\n      each(this.__.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    // custom internal unmount function to avoid relying on the observable\n    if (this.__.onUnmount) { this.__.onUnmount(); }\n\n    if (!skipAnonymous) {\n      this.trigger('unmount');\n      this.off('*');\n    }\n\n    defineProperty(this, 'isMounted', false);\n\n    delete this.root._tag;\n\n    return this\n\n  }.bind(this));\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) ||\n    getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Inherit properties from a target tag instance\n * @this Tag\n * @param   { Tag } target - tag where we will inherit properties\n * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n */\nfunction inheritFrom(target, propsInSyncWithParent) {\n  var this$1 = this;\n\n  each(Object.keys(target), function (k) {\n    // some properties must be always in sync with the parent tag\n    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\n    if (isUndefined(this$1[k]) || mustSync) {\n      // track the property to keep in sync\n      // so we can keep it updated\n      if (!mustSync) { propsInSyncWithParent.push(k); }\n      this$1[k] = target[k];\n    }\n  });\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tagName, newPos) {\n  var parent = this.parent,\n    tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag$1(child, opts, innerHTML),\n    tagName = opts.tagName || getTagName(opts.root, true),\n    ptag = getImmediateCustomParentTag(parent);\n  // fix for the parent attribute in the looped elements\n  defineProperty(tag, 'parent', ptag);\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag.__.parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = '';\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag;\n  while (ptag.__.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function(expr) {\n    if (expr instanceof Tag$1) { expr.unmount(true); }\n    else if (expr.tagName) { expr.tag.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom, skipDataIs) {\n  var child = getTag(dom),\n    namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag$1) && !(data && isFunction(data.trigger)))\n    { return data }\n\n  var o = {};\n  for (var key in data) {\n    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n  }\n  return o\n}\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n * @param { Number } index - add the new item in a certain array position\n */\nfunction arrayishAdd(obj, key, value, ensureArray, index) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n  var hasIndex = !isUndefined(index);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else {\n    if (isArr) {\n      var oldIndex = dest.indexOf(value);\n      // this item never changed its position\n      if (oldIndex === index) { return }\n      // remove the item from its old position\n      if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n      // move or add the item\n      if (hasIndex) {\n        dest.splice(index, 0, value);\n      } else {\n        dest.push(value);\n      }\n    } else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    var index = obj[key].indexOf(value);\n    if (index !== -1) { obj[key].splice(index, 1); }\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName],\n    implClass = __TAG_IMPL[tagName].class,\n    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\n  // clear the inner html\n  root.innerHTML = '';\n\n  var conf = extend({ root: root, opts: opts }, { parent: opts ? opts.parent : null });\n\n  if (impl && root) { Tag$1.apply(tag, [impl, conf, innerHTML]); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n/**\n * makes a tag virtual and replaces a reference in the dom\n * @this Tag\n * @param { tag } the tag to make virtual\n * @param { ref } the dom reference location\n */\nfunction makeReplaceVirtual(tag, ref) {\n  var frag = createFrag();\n  makeVirtual.call(tag, frag);\n  ref.parentNode.replaceChild(frag, ref);\n}\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder(),\n    tail = createDOMPlaceholder(),\n    frag = createFrag(),\n    sib, el;\n\n  this.root.insertBefore(head, this.root.firstChild);\n  this.root.appendChild(tail);\n\n  this.__.head = el = head;\n  this.__.tail = tail;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1.__.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target.__.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this.__.head,\n    frag = createFrag(),\n    sib;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1.__.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target.__.head);\n      break\n    }\n  }\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction selectTags(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + selectTags(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n\nvar tags = Object.freeze({\n\tgetTag: getTag,\n\tinheritFrom: inheritFrom,\n\tmoveChildTag: moveChildTag,\n\tinitChildTag: initChildTag,\n\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\tunmountAll: unmountAll,\n\tgetTagName: getTagName,\n\tcleanUpData: cleanUpData,\n\tarrayishAdd: arrayishAdd,\n\tarrayishRemove: arrayishRemove,\n\tmountTo: mountTo,\n\tmakeReplaceVirtual: makeReplaceVirtual,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tselectTags: selectTags\n});\n\n/**\n * Riot public api\n */\nvar settings = settings$1;\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\n// export the core props/methods\nvar Tag$$1 = Tag$2;\nvar tag$$1 = tag$1;\nvar tag2$$1 = tag2$1;\nvar mount$$1 = mount$1;\nvar mixin$$1 = mixin$1;\nvar update$$1 = update$1;\nvar unregister$$1 = unregister$1;\nvar version$$1 = version$1;\nvar observable = observable$1;\n\nvar riot$1 = extend({}, core, {\n  observable: observable$1,\n  settings: settings,\n  util: util,\n});\n\nexports.settings = settings;\nexports.util = util;\nexports.Tag = Tag$$1;\nexports.tag = tag$$1;\nexports.tag2 = tag2$$1;\nexports.mount = mount$$1;\nexports.mixin = mixin$$1;\nexports.update = update$$1;\nexports.unregister = unregister$$1;\nexports.version = version$$1;\nexports.observable = observable;\nexports['default'] = riot$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot/riot.js\n// module id = 1\n// module chunks = 0","riot.tag2('header', '<button each=\"{navItems}\" onclick=\"{parent.route}\" type=\"button\" class=\"{parent.currentView === this.view ? \\'active btn btn-space btn-outline-primary\\' : \\'btn btn-space btn-outline-primary\\'}\">{this.title}</button>', '', '', function(opts) {\n\nthis.currentView = riot.routeState.view;\n\nthis.navItems = [{ title: 'Home', view: 'home' }, { title: 'Projects', view: 'projects' }];\n\nthis.route = evt => {\n  riot.route(evt.item.view);\n};\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/header.tag","riot.tag2('itemlist', '<div class=\"row\"> <div class=\"col-md-6\"> <h3>{opts.title}</h3> <ul> <li each=\"{items}\">{this.name}</li> </ul> </div> <div class=\"col-md-6\"> <h3>{opts.title}</h3> <ul> <li each=\"{items}\">{this.name}</li> </ul> </div> </div>', '', '', function(opts) {\nvar _this = this;\n\nthis.items = [];\n\nthis.on('mount', () => {\n  riot.control.trigger(riot.EVT.loadItems);\n});\n\nriot.control.on(riot.EVT.loadItemsSuccess, items => {\n  _this.items = items;\n  _this.update();\n});\n});\n\n\n// WEBPACK FOOTER //\n// ./src/components/itemlist.tag","import '../components/header.tag';\nimport '../components/itemlist.tag';\n\nriot.tag2('home', '<header></header> <div class=\"container\"> <itemlist title=\"Item List ABC\"></itemlist> </div>', '', '', function(opts) {\n});\n\n\n// WEBPACK FOOTER //\n// ./src/pages/home.tag","import '../components/header.tag';\nimport '../components/itemlist.tag';\n\nriot.tag2('projects', '<header></header> <div class=\"container\"> <h2>Projects</h2> <p> Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aspernatur quia soluta optio excepturi, earum saepe explicabo veritatis fuga nesciunt, reprehenderit harum. Libero consequuntur neque fuga eos, aliquam id beatae eaque? </p> </div>', '', '', function(opts) {\n});\n\n\n// WEBPACK FOOTER //\n// ./src/pages/projects.tag","import Riotcontrol from 'riotcontrol';\r\n\r\nriot.control = Riotcontrol;\r\n\r\n// event names\r\n\r\nriot.EVT = {\r\n  loadItems : 'load_items',\r\n  loadItemsSuccess : 'load_items_success'\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/event-helper.js"," \r\nimport './css/index.css';\r\nimport './event-helper';\r\nimport './stores/itemstore';\r\nimport './router.js';\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import route from 'riot-route'\r\nimport './pages/home.tag'\r\nimport './pages/projects.tag'\r\n\r\n// we need this to easily check the current route from every component\r\nriot.route = route\r\nriot.routeState = {\r\n  view : ''\r\n};\r\n\r\nclass Router{\r\n\r\n  constructor(){\r\n    this._currentView = null;\r\n    this._views = ['home', 'projects'];\r\n    this._defaultView = 'home';\r\n    \r\n    riot.route(this._handleRoute.bind(this));\r\n    riot.route.exec(this._handleRoute.bind(this));\r\n  }\r\n\r\n  _handleRoute(view){\r\n\r\n    // load default view, if view is not in views list\r\n    if(this._views.indexOf(view) === -1){\r\n      return riot.route(this._defaultView);\r\n    }\r\n\r\n    this._loadView(view); \r\n  }\r\n\r\n  _loadView(view){\r\n    if (this._currentView) {\r\n      this._currentView.unmount(true);\r\n    }\r\n\r\n    riot.routeState.view = view;\r\n    this._currentView = riot.mount('#riot-app', view)[0];\r\n  }\r\n\r\n}\r\n\r\nexport default new Router();\n\n\n// WEBPACK FOOTER //\n// ./src/router.js","class ItemStore{\r\n\r\n  constructor(){\r\n    riot.observable(this);\r\n    this.items = [];\r\n\r\n    this.bindEvents();\r\n  }\r\n\r\n  bindEvents(){\r\n    this.on(riot.EVT.loadItems, () => {\r\n      \r\n      // fake async op \r\n      setTimeout(() => {\r\n        this.items = [{ name : 'test a' },{ name : 'test b' } ,{ name : 'test c' }, { name : 'test d' }];\r\n        this.trigger(riot.EVT.loadItemsSuccess, this.items);\r\n      }, 200);\r\n\r\n    });\r\n  }\r\n\r\n}\r\n\r\n// add store to riot control\r\nlet itemStore = new ItemStore();\r\nriot.control.addStore(itemStore);\r\n\r\nexport default itemStore;\n\n\n// WEBPACK FOOTER //\n// ./src/stores/itemstore.js","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".btn-space{margin-right:5px}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/postcss-loader!./src/css/index.css\n// module id = 10\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function() {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\tvar result = [];\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar item = this[i];\n\t\t\tif(item[2]) {\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\n\t\t\t} else {\n\t\t\t\tresult.push(item[1]);\n\t\t\t}\n\t\t}\n\t\treturn result.join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 11\n// module chunks = 0",";(function(window, undefined) {var observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          (callbacks[event] = callbacks[event] || []).push(fn)\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) callbacks = {}\n        else {\n          if (fn) {\n            var arr = callbacks[event]\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) arr.splice(i--, 1)\n            }\n          } else delete callbacks[event]\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on)\n          fn.apply(el, arguments)\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments[i + 1] // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0)\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args)\n        }\n\n        if (callbacks['*'] && event != '*')\n          el.trigger.apply(el, ['*', event].concat(args))\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  })\n\n  return el\n\n}\n  /* istanbul ignore next */\n  // support CommonJS, AMD & browser\n  if (typeof exports === 'object')\n    module.exports = observable\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return observable })\n  else\n    window.observable = observable\n\n})(typeof window != 'undefined' ? window : undefined);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot-observable/dist/observable.js\n// module id = 12\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar observable = _interopDefault(require('riot-observable'));\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\nvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/;\nvar EVENT_LISTENER = 'EventListener';\nvar REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER;\nvar ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER;\nvar HAS_ATTRIBUTE = 'hasAttribute';\nvar POPSTATE = 'popstate';\nvar HASHCHANGE = 'hashchange';\nvar TRIGGER = 'trigger';\nvar MAX_EMIT_STACK_LEVEL = 3;\nvar win = typeof window != 'undefined' && window;\nvar doc = typeof document != 'undefined' && document;\nvar hist = win && history;\nvar loc = win && (hist.location || win.location);\nvar prot = Router.prototype;\nvar clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click';\nvar central = observable();\n\nvar started = false;\nvar routeFound = false;\nvar debouncedEmit;\nvar base;\nvar current;\nvar parser;\nvar secondParser;\nvar emitStack = [];\nvar emitStackLevel = 0;\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var f = filter\n    .replace(/\\?/g, '\\\\?')\n    .replace(/\\*/g, '([^/?#]+?)')\n    .replace(/\\.\\./, '.*');\n  var re = new RegExp((\"^\" + f + \"$\"));\n  var args = path.match(re);\n\n  if (args) { return args.slice(1) }\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t;\n  return function () {\n    clearTimeout(t);\n    t = setTimeout(fn, delay);\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1);\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit);\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n  doc[ADD_EVENT_LISTENER](clickEvent, click);\n  if (autoExec) { emit(true); }\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = [];\n  observable(this); // make it observable\n  central.on('stop', this.s.bind(this));\n  central.on('emit', this.e.bind(this));\n}\n\nfunction normalize(path) {\n  return path.replace(/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href).replace(RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] === '#'\n    ? (href || loc.href || '').split(base)[1] || ''\n    : (loc ? getPathFromRoot(href) : href || '').replace(base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel === 0;\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) { return }\n\n  emitStackLevel++;\n  emitStack.push(function() {\n    var path = getPathFromBase();\n    if (force || path !== current) {\n      central[TRIGGER]('emit', path);\n      current = path;\n    }\n  });\n  if (isRoot) {\n    var first;\n    while (first = emitStack.shift()) { first(); } // stack increses within this call\n    emitStackLevel = 0;\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which !== 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) { return }\n\n  var el = e.target;\n  while (el && el.nodeName !== 'A') { el = el.parentNode; }\n\n  if (\n    !el || el.nodeName !== 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target !== '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) === -1 // cross origin\n  ) { return }\n\n  if (el.href !== loc.href\n    && (\n      el.href.split('#')[0] === loc.href.split('#')[0] // internal jump\n      || base[0] !== '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || base[0] === '#' && el.href.split(base)[0] !== loc.href.split(base)[0] // outside of #base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    )) { return }\n\n  e.preventDefault();\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @param {boolean} shouldReplace - use replaceState or pushState\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title, shouldReplace) {\n  // Server-side usage: directly execute handlers for the path\n  if (!hist) { return central[TRIGGER]('emit', getPathFromBase(path)) }\n\n  path = base + normalize(path);\n  title = title || doc.title;\n  // browsers ignores the second parameter `title`\n  shouldReplace\n    ? hist.replaceState(null, title, path)\n    : hist.pushState(null, title, path);\n  // so we need to set it manually\n  doc.title = title;\n  routeFound = false;\n  emit();\n  return routeFound\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * two strings and boolean:        replace history with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n * @param {boolean} third - replace flag\n */\nprot.m = function(first, second, third) {\n  if (isString(first) && (!second || isString(second))) { go(first, second, third || false); }\n  else if (second) { this.r(first, second); }\n  else { this.r('@', first); }\n};\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*');\n  this.$ = [];\n};\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter === '@' ? parser : secondParser)(normalize(path), normalize(filter));\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args));\n      return routeFound = true // exit from loop\n    }\n  }, this);\n};\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter !== '@') {\n    filter = '/' + normalize(filter);\n    this.$.push(filter);\n  }\n  this.on(filter, action);\n};\n\nvar mainRouter = new Router();\nvar route = mainRouter.m.bind(mainRouter);\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router();\n  // assign sub-router's main method\n  var router = newSubRouter.m.bind(newSubRouter);\n  // stop only this sub-router\n  router.stop = newSubRouter.s.bind(newSubRouter);\n  return router\n};\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#';\n  current = getPathFromBase(); // recalculate current path\n};\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true);\n};\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER;\n    secondParser = DEFAULT_SECOND_PARSER;\n  }\n  if (fn) { parser = fn; }\n  if (fn2) { secondParser = fn2; }\n};\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {};\n  var href = loc.href || current;\n  href.replace(/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v; });\n  return q\n};\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    if (win) {\n      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit);\n      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n      doc[REMOVE_EVENT_LISTENER](clickEvent, click);\n    }\n    central[TRIGGER]('stop');\n    started = false;\n  }\n};\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (win) {\n      if (document.readyState === 'interactive' || document.readyState === 'complete') {\n        start(autoExec);\n      }\n      else {\n        document.onreadystatechange = function () {\n          if (document.readyState === 'interactive') {\n            // the timeout is needed to solve\n            // a weird safari bug https://github.com/riot/route/issues/33\n            setTimeout(function() { start(autoExec); }, 1);\n          }\n        };\n      }\n    }\n    started = true;\n  }\n};\n\n/** Prepare the router **/\nroute.base();\nroute.parser();\n\nmodule.exports = route;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot-route/index.js\n// module id = 13\n// module chunks = 0","var RiotControl = {\r\n  _stores: [],\r\n  addStore: function(store) {\r\n    this._stores.push(store);\r\n  },\r\n  reset: function() {\r\n    this._stores = [];\r\n  }\r\n};\r\n\r\n['on','one','off','trigger'].forEach(function(api){\r\n  RiotControl[api] = function() {\r\n    var args = [].slice.call(arguments);\r\n    this._stores.forEach(function(el){\r\n      el[api].apply(el, args);\r\n    });\r\n  };\r\n});\r\n\r\nif (typeof(module) !== 'undefined') module.exports = RiotControl;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riotcontrol/riotcontrol.js\n// module id = 14\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\tlinkElement.rel = \"stylesheet\";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 15\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/postcss-loader/index.js!./index.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!../../node_modules/postcss-loader/index.js!./index.css\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/postcss-loader/index.js!./index.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/css/index.css\n// module id = 16\n// module chunks = 0"],"sourceRoot":""}